Tags: continuous deployment, разработка ПО, CI/CD, DevOps, системы сборки, gradle
PAA: ??? 
Labels:  gradle, kotlin

# Сборка (CI/CD) проектов

Во многих проектах сборке отводится незначительная роль. Основные усилия команда
сосредоточивает на разработке кода. В больших гетерогенных проектах 
сборка оказывается достаточно сложной и к ней вполне можно подходить как 
к самостоятельному проекту.

В этой заметке мы рассмотрим, по каким критериям мы выбирали инструментарий, а 
[в следующей](build-systems-2-gradle-howto-ru.md) — 
каким образом этот инструментарий используем.

[![CI/CD (opensource.com)](https://opensource.com/sites/default/files/uploads/devops_pipeline_pipe-2.png)](https://opensource.com/article/19/7/cicd-pipeline-rule-them-all)

## Общая модель сборки проектов

Модель сборки проектов во всех рассматриваемых инструментах
представляет собой [направленный граф без циклов](https://ru.wikipedia.org/wiki/Ориентированный_ациклический_граф)
([орграф, DAG](https://en.wikipedia.org/wiki/Directed_acyclic_graph)), а не структурный подход
(когда процедура вызывает другие процедуры, а затем пользуется результатами).
Связано это с тем, что при разработке проекта вносятся небольшие изменения и бо́льшая часть
операций по сборке не требуется. То есть организация проекта в форме орграфа является 
основой для того, чтобы выполнялись только те действия, 
которые необходимы для ближайшей задачи, тем самым часто используемые операции 
будут выполняться достаточно быстро.


Узлами в графе являются цели или задачи. Цели — результаты, которые необходимо достичь, 
а задачи — операции, которые надо выполнить, чтобы достичь текущей цели. При этом задача может
быть запущена только в том случае, когда все зависимости удовлетворены.

Поверх этой основной модели в ряде инструментов реализованы более высокоуровневые модели.

## Выбор инструмента

При старте проекта иногда бывает можно оценить, насколько сложной окажется интеграция проекта.
В нашем случае оказалось, что требуется собирать несколько модулей node.js, несколько go-lang, 
осуществлять развёртывание нескольких модулей terraform (и ни одного jvm-модуля).

В других аналогичных проектах, развивавшихся "органически", сборка осуществлялась с 
использованием `make`, а в скриптах сборки использовались `bash`, `perl`, 
`curl`, `php` и др. Механизм сборки было трудно поддерживать, производительность
оставляла желать лучшего и ряд возможностей не был реализован.

Для нового проекта мы задумались, какой инструмент взять за основу системы 
сборки. Оценили такие варианты:

- make,
- ant,
- maven,
- sbt,
- gradle/groovy,
- gradle/kotlin.

<cut/>


### Make

Эта программа создана достаточно давно, широко применяется во многих проектах и, в целом,
позволяет реализовывать сборку достаточно больших и сложных проектов.

Плюсы
- наличие компетенции;
- похож на shell;

Минусы
- поддерживается только базовая модель целей и задач, нет поддержки понятия проекта;
- запутанный синтаксис;
- глобальные состояния;
- нет поддержки плагинов, трудно повторно использовать части кода;
- отсутствует возможность декларативного описания сборки; только императивный код.

В отсутствии ограничений, в скриптах сборки можно встретить 
- генерацию шаблонов с помощью perl, 
- установку недостающих исполняемых файлов путём исполнения .sh скриптов из интернета 
при каждом запуске скрипта,
- вызов make-файлов для подпроектов с нестандартными названиями целей,
- отсутствие согласованной обработки ошибок.

Такие неожиданности затрудняют поддержку и делают сборку небезопасной операцией.

### Ant

Похож на make, только на платформе JVM. Скрипт записывается в `.xml`. 
Детально не рассматривали, т.к. на JVM есть более современные преемники.

### Maven

Maven стал революцией в системах сборки в момент своего появления. Идеи декларативного
описания проектов, широкого применения конвенций, использования плагинов, 
хранения артефактов в репозиториях, 
использования системы идентификации, включающей версии — всё это обеспечило 
признание и широкое использование во многих JVM-проектах по сей день.

Плюсы
- наличие компетенции;
- развитая модель проектов и подпроектов;
- поддержка плагинов;
- декларативная модель;
- maven wrapper.

Минусы
- слабая поддержка других технологий;
- трудоёмкость реализации плагинов;
- отсутствие удобной возможности реализации императивных скриптов;
- жёсткая структура жизненного цикла;
- не очень удобный XML-формат.

Отсутствие императивных скриптов является и плюсом и минусом. С одной стороны, 
декларативный подход обеспечивает жёсткое разделение кода и модели, с другой стороны,
задачи сборки зачастую требуют отдельных вставок императивной логики, и решение таких задач
в maven'е мучительно.

### Sbt

Sbt — инструмент сборки Scala-проектов. Появился примерно в то же время, что и gradle.

Плюсы
- развитый язык;
- поддержка плагинов и императивных вставок;
- поддержка инкрементной сборки;
- поддержка непрерывной сборки по мере изменения;
- параллельное исполнение.

Минусы
- неожиданная модель (вместо задач — "настройки");
- неявные зависимости через `.value`;
- слабая поддержка других технологий (go, node.js);
- неожиданный синтаксис.

### Gradle

Gradle появился в 2007 году в качестве ответа на основные ограничения maven — отсутствие императивного
кода, трудность реализации плагинов, неудобство при нестандартных операциях.
Gradle базируется на идеях, предложенных Maven'ом, развивает их и меняет акценты.
Основными частями модели gradle являются:
- задачи (Task) — выполняемые операции, узел графа зависимостей, имя+описание;
- проект — логическая единица организации кода, совокупность и scope задач,
  точка подключения плагинов;
- плагин — возможность или фича, добавляемая в проект. Среди прочего — набор задач;
- зависимости, проверка up-to-date.

Важным усовершенствованием стало использование DSL, основанного на императивном языке, 
с помощью которого формируются элементы декларативной модели, а также решаются
императивные задачи.

Плюсы
- поддержка модели проектов;
- поддержка декларативного (основанного на модели) и императивного подхода одновременно;
- поддержка инкрементной сборки;
- непревзойденная гибкость; 
- превосходная документация (для двух диалектов сразу);
- очень быстрая работа (даже определения тасков выполняются 
  только в случае необходимости);
- кросс-платформенность — работает везде;
- gradle wrapper — небольшой скрипт для загрузки и запуска gradle правильной версии;
  разработчикам не требуется вручную настраивать утилиты и обновлять при изменении версии в репозитории; 
- удобный и понятный DSL.

Минусы
- отсутствие компетенции;
- нет естественных барьеров против засилья императивного кода. Необходимы дисциплина и 
  следование рекомендованным практикам при разработке скриптов сборки во
  избежание макаронного кода. В gradle, насколько мне известно, отсутствуют
  механизмы защиты от чрезмерного использования императивного кода.
- не поддерживаются иные механизмы зависимостей, кроме JVM (maven-repository, ivy2);
- необходимость предпринимать усилия для того, чтобы каждая задача поддерживала
  проверку up-to-date (полезную для инкрементной сборки). В принципе, обычные возможности DAG доступны без усилий,
  но gradle позволяет достигнуть ещё более высокой скорости работы при условии
  указания входов и выходов.


#### Выбор диалекта — gradle/groovy или gradle/kotlin

Изначально gradle использовался с помощью groovy-DSL. В дальнейшем был разработан 
DSL на основе Kotlin'а.

Плюсы Kotlin'а
- компилируемый строго-типизированный язык:
  — защита от ошибок на этапе компиляции,
  — поддержка intelli-sense,
  — безопасный рефакторинг,
- хорошая поддержка DSL,
- простой синтаксис, меньше бойлерплейта, по сравнению с Java, 
- достаточно много сахара,

Минусы
- на просторах интернета большинство примеров — для groovy, вначале бывает трудно сообразить,
  как переписать пример на kotlin'е.
- немного повышается порог входа в связи с необходимостью освоения нового языка.

#### gradle/kotlin vs make

Ниже приведены сравнительные преимущества gradle/kotlin по отношению к make:

Преимущества:

- высочайшая скорость работы. Команда Gradle прикладывает постоянные усилия
  в направлении улучшения скорости и в реализации инструментов, способствующих
  реализации высокоскоростных скриптов. Можно добиться того, что все задачи,
  не требующие выполнения, будут пропущены. А задачи, требующие выполнения — выполнены 
  только для изменившихся файлов.  
- унификация языка. Все задачи решаются в рамках одного 
  компилируемого строго-типизированного языка с согласованным и продуманным синтаксисом — Kotlin.
  Нет необходимости изучать особенности режимов make, различия версий shell-интерпретаторов,
  варианты обработки параметров командной строки в разных утилитах,
  отдельные языки программирования для шаблонов (php?, perl?). 
  За счёт использования современного языка со статической
  типизацией, исключается множество классов ошибок, характерных для скриптовых языков.
- декларативная модель проектов/подпроектов и плагинов поверх 
  декларативного орграфа задач. В make — только непосредственно императивные задачи.
- возможность комбинирования декларативного и императивного подхода.
  Несмотря на то, что декларативный подход обеспечивает понятность и чистоту кода,
  лёгкость поддержки, возможности комбинирования компонентов; императивный подход
  может оказаться незаменимым в силу своей гибкости. Новые задачи можно вначале
  решить императивным способом (ad-hoc), а затем обобщить и выделить в форме
  декларативных конфигурируемых плагинов.
- возможность создания повторно-используемых плагинов. Причем написание таких плагинов не 
  вызывает особых сложностей и плагинам предоставляется удобный API с широкими возможностями.
  В случае make стандартных механизмов не предусмотрено, из-за чего возникает дублиирование
  кода и переизобретение велосипедов.
- платформа JVM, на которой реализованы библиотеки на все случаи жизни.
  В make некоторые задачи требуют установки платформо-специфических приложений 

Недостатки
- неудобно вызывать shell-команды. Для каждой команды надо создать и настроить task. 
- более высокие требования к инженерной культуре — язык со статической типизацией, декларативная
  модель проекта, использование развитых концепций (свойства, вывод зависимостей, проверки up-to-date).

## Заключение

В этом посте мы рассмотрели выбор инструментария сборки проекта и ci/cd. В конце концов
остановились на варианте gradle/kotlin. Этот вариант обладает рядом преимуществ в сравнении
с реализацией сборки проекта на основе make/shell. 

В следующей части рассмотрим некоторые особенности применения gradle/kotlin к сборке 
не-JVM проектов.


### Благодарности

Хотелось бы поблагодарить Антона Поцюса, @Starcounter, Алексея Жукова
за конструктивную критику черновика статьи.
