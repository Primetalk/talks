Tags: continuous deployment, разработка ПО, CI/CD, DevOps, системы сборки, gradle
PAA: ??? 
Labels:  gradle, kotlin

# Сборка (CI/CD) проектов

Во многих проектах сборке отводится незначительная роль. Основные усилия команда
сосредоточивает на разработке кода. В больших гетерогенных проектах 
сборка оказывается достаточно сложной и к ней вполне можно подходить как 
к самостоятельному проекту.

В этой заметке мы рассмотрим, по каким критериям мы выбирали инструментарий, а 
[в следующей](build-systems-2-gradle-howto-ru.md) — 
каким образом этот инструментарий используем.

## Общая модель сборки проектов

Модель сборки проектов во всех рассматриваемых инструментах
представляет собой направленный граф без циклов (орграф, DAG). 
Связано это с тем, что при разработке проекта вносятся небольшие изменения и бо́льшая часть
операций по сборке не требуется. То есть организация проекта в форме орграфа является 
основой для того, чтобы типовые операции производились достаточно быстро.

TODO: дедублировать
Почему для сборки используется не структурированный подход
(процедура вызывает другие процедуры, а затем пользуется результатами), а
[направленный граф](https://ru.wikipedia.org/wiki/Ориентированный_ациклический_граф)
([DAG](https://en.wikipedia.org/wiki/Directed_acyclic_graph))? Это связано
с желанием выполнять только те действия, которые необходимы для ближайшей задачи.

Узлами в таком графе являются цели или задачи. Цели — результаты, которые необходимо достичь, 
а задачи — операции, которые надо выполнить, чтобы достичь текущей цели. При этом задача может
быть запущена только в том случае, когда все зависимости удовлетворены.

Поверх этой основной модели в ряде инструментов реализованы более высокоуровневые модели.

## Выбор инструмента

При старте проекта иногда бывает можно оценить, насколько сложной окажется интеграция проекта.
В нашем случае оказалось, что требуется собирать несколько модулей node.js, несколько go-lang, 
осуществлять развёртывание нескольких модулей terraform (и ни одного jvm-модуля).

В других аналогичных проектах, развивавшихся "органически", сборка осуществлялась с 
использованием `make`, а в скриптах сборки использовались `bash`, `perl`, 
`curl`, `php` и др. Механизм сборки было трудно поддерживать, производительность
оставляла желать лучшего и ряд возможностей не был реализован.

Для нового проекта мы задумались, какой инструмент взять за основу системы 
сборки. Оценили такие варианты:

- make,
- ant,
- maven,
- sbt,
- gradle/groovy,
- gradle/kotlin.

<cut/>


### Make

Эта программа создана достаточно давно, широко применяется во многих проектах и, в целом,
позволяет реализовывать сборку достаточно больших и сложных проектов.

Плюсы
- наличие компетенции;
- похож на shell;

Минусы
- поддерживается только базовая модель целей и задач, нет поддержки понятия проекта;
- запутанный синтаксис;
- глобальные состояния;
- нет поддержки плагинов, трудно повторно использовать части кода;
- отсутствует возможность декларативного описания сборки; только императивный код;

В отсутствии ограничений, в скриптах сборки можно встретить 
- генерацию шаблонов с помощью perl, 
- установку недостающих исполняемых файлов путём исполнения .sh скриптов из интернета 
при каждом запуске скрипта,
- вызов make-файлов для подпроектов,
- отсутствие согласованной обработки ошибок.

Такие неожиданные явления затрудняют поддержку и делают сборку небезопасной операцией.

### Ant

Похож на make, только на платформе JVM. Скрипт записывается в `.xml`. 
Детально не рассматривали, т.к. на JVM есть более современные преемники.

### Maven

Maven стал революцией в системах сборки в момент своего появления. Идеи декларативного
описания проектов, широкого применения конвенций, использования плагинов, 
хранения артефактов в репозиториях, 
использования системы идентификации, включающей версии — всё это обеспечило 
признание и широкое использование во многих JVM-проектах по сей день.

Плюсы
- наличие компетенции;
- развитая модель проектов и подпроектов;
- поддержка плагинов;
- декларативная модель;
- maven wrapper.

Минусы
- слабая поддержка других технологий;
- трудоёмкость реализации плагинов;
- отсутствие удобной возможности реализации императивных скриптов;
- жёсткая структура жизненного цикла;
- не очень удобный XML-формат.

Отсутствие императивных скриптов является и плюсом и минусом. С одной стороны, 
декларативный подход обеспечивает жёсткое разделение кода и модели, с другой стороны,
задачи сборки зачастую требуют отдельных вставок императивной логики, и решение таких задач
в maven'е мучительно.

### Sbt

Sbt — инструмент сборки Scala-проектов. Появился примерно в то же время, что и gradle.

Плюсы
- развитый язык;
- поддержка плагинов и императивных вставок;
- поддержка инкрементной сборки;
- поддержка непрерывной сборки по мере изменения;
- параллельное исполнение;

Минусы
- неожиданная модель (вместо задач — "настройки");
- неявные зависимости через `.value`;
- слабая поддержка других технологий (go, node.js);
- неожиданный синтаксис;

### gradle

Gradle появился в 2007 году в качестве ответа на основные ограничения maven — отсутствие императивного
кода, трудность реализации плагинов, неудобство при нестандартных операциях. 
Грэдл базируется на идеях, предложенных Maven'ом, развивает их и меняет акценты.
Основными частями модели грэдл являются:
- задачи (Task) — выполняемые операции, узел графа зависимостей, имя+описание;
- проект — логическая единица организации кода, совокупность и scope задач,
  точка подключения плагинов;
- плагин — возможность или фича, добавляемая в проект. Среди прочего — набор задач;
- зависимости, проверка up-to-date.

Важным усовершенствованием стало использование DSL, основанного на императивном языке, 
с помощью которого формируются элементы декларативной модели, а также решаются
императивные задачи.

Плюсы
- поддержка модели проектов;
- поддержка декларативного (основанного на модели) и императивного подхода одновременно;
- поддержка инкрементной сборки;
- непревзойденная гибкость; 
- в основе модели исполнения — DAG задач;
- превосходная документация (для двух диалектов сразу);
- очень быстрая работа (даже определения тасков выполняются 
  только в случае необходимости);
- кросс-платформенность — работает везде;
- gradle wrapper — небольшой скрипт для загрузки и запуска gradle правильной версии;
- удобный и понятный DSL.

Минусы
- отсутствие компетенции;
- нет естественных барьеров против засилья императивного кода. Необходимы дисциплина и 
  следование рекомендованным практикам. В gradle, насколько мне известно, отсутствуют
  механизмы защиты от чрезмерного использования императивного кода.
- TODO: дедублировать
- необходимость соблюдения самодисциплины при разработке скриптов сборки во
  избежание макаронного кода.
- не поддерживаются иные механизмы зависимостей, кроме JVM (maven, ivy2);
- необходимость предпринимать усилия для того, чтобы каждая задача поддерживала
  проверку up-to-date (полезную для инкрементной сборки). В принципе, обычные возможности DAG доступны без усилий,
  но gradle позволяет достигнуть ещё более высокой скорости работы при условии
  указания входов и выходов.


#### Выбор диалекта — gradle/groovy или gradle/kotlin

Изначально gradle использовался с помощью groovy-DSL. В дальнейшем был разработан 
DSL на основе Kotlin'а.

Плюсы Kotlin'а
- компилируемый строго-типизированный язык:
  — защита от ошибок на этапе компиляции,
  — поддержка intelli-sense,
  — безопасный рефакторинг,
- хорошая поддержка DSL,
- простой синтаксис, меньше бойлерплейта, по сравнению с Java, 
- достаточно много сахара,

Минусы
- на просторах интернета большинство примеров — для groovy, вначале бывает трудно сообразить,
  как переписать пример на kotlin'е.
- немного повышается порог входа в связи с необходимостью освоения нового языка.

#### gradle/kotlin vs make

Ниже приведены сравнительные преимущества gradle/kotlin по отношению к make:

Преимущества:

- высочайшая скорость работы. Команда Gradle прикладывает постоянные усилия
  в направлении улучшения скорости и в реализации инструментов, способствующих
  реализации высокоскоростных скриптов. Можно добиться того, что все задачи,
  не требующие выполнения, будут пропущены. А задачи, требующие выполнения — выполнены 
  только для изменившихся файлов.  
- унификация языка. Все задачи решаются в рамках одного 
  компилируемого строго-типизированного языка с согласованным и продуманным синтаксисом — Kotlin.
  Нет необходимости изучать особенности режимов make, различия версий shell-интерпретаторов,
  варианты обработки параметров командной строки в разных утилитах,
  отдельные языки программирования для шаблонов (php?, perl?). 
  За счёт использования современного языка со статической
  типизацией, исключается множество классов ошибок, характерных для скриптовых языков.
- декларативная модель проектов/подпроектов и плагинов поверх 
  декларативного орграфа задач. В make — только непосредственно императивные задачи.
- возможность комбинирования декларативного и императивного подхода.
  Несмотря на то, что декларативный подход обеспечивает понятность и чистоту кода,
  лёгкость поддержки, возможности комбинирования компонентов; императивный подход
  может оказаться незаменимым в силу своей гибкости. Новые задачи можно вначале
  решить императивным способом (ad-hoc), а затем обобщить и выделить в форме
  декларативных конфигурируемых плагинов.
- возможность создания повторно-используемых плагинов. Причем написание таких плагинов не 
  вызывает особых сложностей и плагинам предоставляется удобный API с широкими возможностями.
  В случае make стандартных механизмов не предусмотрено, из-за чего возникает дублиирование
  кода и переизобретение велосипедов.
- платформа JVM, на которой реализованы библиотеки на все случаи жизни.
  В make некоторые задачи требуют установки платформо-специфических приложений 


## Заключение

В этом посте мы рассмотрели выбор инструментария сборки проекта и CI/CD. В конце концов
остановились на варианте gradle/kotlin. Этот вариант обладает рядом преимуществ в сравнении
с реализацией сборки проекта на основе make/shell. 

В следующей части рассмотрим некоторые особенности применения gradle/kotlin к сборке 
не-JVM проектов.


### Благодарности

Хотелось бы поблагодарить Антона Поцюса, @Starcounter, Алексея Жукова
за конструктивную критику черновика статьи.



### План

2. Часть 1. Выбор инструмента (make/shell, ant, maven, sbt, gradle/groovy, gradle/kotlin)

- Во многих прежних проектах — костыли

#### JVM

- Каждый jar-ник — в artifactory
- сборка Java-проектов

#### выбор систем сборки
- классификация систем сборки??
- эволюция систем сборки
- cmake — генерация скриптов сборки??
- использование gradle, gradle.kts, плагинов
- sbt — в чём проблема — мутабельная модель, вообще говоря

#### про gradle/kotlin
- порог входа в gradle.kts
- + переключение groovy/kts — больно
- + документация: родная — высочайшего класса. Стэк оверфлоу — на груви. Гугл не позволяет найти на kotlin'е. Обнаруживаемость (discoverability) — не очень
- удачный кейс?
- kts — поддержка intelli-sense.
- + gradle-скрипты — ужас-ужас.
- грабли
- как не надо писать
- + пример DSL из косогор-плагина
- + котлин позволяет, в принципе, неплохой DSL создавать.
- + wrapper — позволяет не задумываться о сборке разработчикам из других областей.
- + кросс-платформенность
- что особенно нравится/бесит:
  — скорость работы
  — быстро, как грэдл — один из selling-point'ов.
  — неудобно вызывать shell-команды
- точки роста — что было бы хорошо допилить
- модель, на которой работает gradle — таски, source set'ы, деревья файлов, проекты,
  свойства
- ленивость, доведённая до высшей точки — даже таски не создаются.

- версионирование?? поддержка semver??

- tips — как обеспечить инкрементную сборку (и пожелание авторам добавить проперти в инкрементную сборку — уже сделано?)

- в чём главный дефект скриптов конфигурирования билда. И почему лучше было бы перейти
  полностью на котлин
- манипулирование моделью проекта с помощью скриптов или как часть плагина
- поддержка скриптов
