Tags: 
PAA: ??? 
КДПВ
Тип: мнение
Labels: тесты, тестирование, качество кода, функциональное программирование
Тестирование
Тестирование IT-систем
Функциональное программирование
Совершенный код
Программирование

# Мета

	[x] тесты, которые ничего не проверяют (отсылку на Андрея Иванова)
	[x] тесты, которые проверяют, но если ломаются, ничего не понять.
	[x] код с большим числом if'ов, который тестируется через ... один вход
	[x] раздутый код + раздутые тесты - 
	[x] моки
	[x] альтернатива (светлая сторона)
		[x] критерии качества:
			[ ] общность программы - насколько много "случаев" охватывает программа
		[x] функциональный подход
		[x] убрать if'ы и boolean-флаги
		[x] строгая типизация
    [x] непредставимость некорректных данных с помощью ADT-типов (https://www.youtube.com/watch?v=IcgmSRJHu_8&amp;ab_channel=elm-conf) Пример CSS, вопрос/ответ.

TODO: Важно также рассматривать степень общности программы — насколько велик класс решаемых задач в сравнении с объёмом исходного кода. ???

Цель: 
  отразить своё видение, как обеспечивать качество ПО
  указать на те проблемы юнит-тестов, которые противоречат моему видению способов обеспечения качества ПО.

  Почему в моём видении нет моков?
  Надо прочитать про моки и понять, каким образом мне до сих пор удавалось обходиться без них.

Задачи:
+ указать место, где стоит использовать юнит-тесты; 
- описать, что можно ожидать от тестов, а чего нельзя;
  - в частности, если обнаружено поведение, противоречащее требованиям (баг), то для него можно написать тест, чтобы в ходе разработки легко воспроизводить эту же самую проблему (если это экономически оправдано). По окончании исправления этот тест в значительной степени теряет свою полезность. Можно оставить как "регрессионное тестирование". Можно удалить через какое-то время.
  - тесты, частично фиксирующие основные требования. При рефакторинге позволяют обнаруживать грубые ошибки.
  - если сами требования сформулированы с условиями/флагами, то тесты должны включать примеры на каждый важный кейс;
+ привести примеры "толковых" тестов;
+ привести примеры "толковых" программ, не нуждающихся в тестах;
+ упомянуть побочные задачи тестирования 
  + демонстрация того, как используется программа (библиотека, фреймворк),
  + обучение членов команды, 
- закон убывающей "предельной" (удельной) полезности - каждый последующий тест приносит, по-видимому, меньше пользы.
+ пример кодирования, гарантирующего работу с базой - `Id` с opaque типом, доступным только при чтении из БД.
  `DBIO[Id]`
+ Ограниченная польза юнит-тестов
+ проанализировать типы ошибок и понять роль тестов/типов в сфере защиты от ошибок. Что разумно требовать от тестов, и чего ожидать не стоит.
- TODO: убрать нападки на моки? или понять, как достичь того же состояния иначе. Например, заменив statful зависимость на stateless, в которой состояние передаётся вместе с вызовом функции, а не в результате нескольких предшествующих действий.
План:
- 1. Бестолковые тесты. Примеры проблем с тестами.
  - ссылки на другие статьи с проблемами тестов
  - 
- 2. Качественное ПО. 
  - понятия, входящие в "качество ПО"
  - абстракции
  - табличное и алгоритмическое задание функции
  - эквивалентность
  1. Пример кодирования на основе типов
- Заключение



TODO: 
    // Основной целью тестирования, на мой взгляд, является проверка того, что программа соответствует требованиям. Другие цели, такие как документирование, обмен знаниями и т.п., играют второстепенную роль. Если тест падает, это должно означать, что какому-то требованию код больше не соответствует. Падение теста должно содержать достаточно информации для понимания контекста и облегчать поиск и устранение ошибки. Например, тестирование endpoint'а зачастую не позволяет понять, что именно пошло не так, т.к. client-side ошибка, возвращаемая HTTP, не содержит подробностей. В то же время, тестирование обработчика может дать больше информации о том, что именно пошло не так.


    // В настоящей заметке приведены несколько примеров тестов, которые не настолько полезны, как могли бы быть. Проблема заключается в принципиальной ограниченности табличных функций, которыми, по-сути, являются тесты. Из-за этой принципиальной ограниченности надежды на то, что написание бо́льшего количества тестов как-то улучшит качество программы, тщетны.

   TODO:   https://www.thinksys.com/qa-testing/types-software-testing-bugs/ 

    Incorrect calculations.
    Boundary-related errors.
    Syntax errors. 
    Performance errors. 
    Compatibility errors. 
    Input validation errors. 
    Memory errors.
    Runtime errors. 
    Logic errors.



TODO: подвести к тестированию с использованием моков. Проблема моков. (в системном подходе)



TODO:

1. Юнит-тесты должны помогать обнаруживать ошибки на более ранних этапах жизненного цикла (до запуска в эксплуатацию).
2. Набор юнит-тестов должен помогать обеспечивать защиту ранее реализованных функций при рефакторинге. (Если функция полностью прекратит работу, то какой-то тест упадёт.)
3. Написание юнит-тестов должно поощрять разработчиков делать код более модульным, тем самым косвенно улучшая его качество.
4. Сами юнит-тесты должны служить документацией к API и помогать понять на рабочих примерах, как им пользоваться.



TODO:

  //     if b then
      if c then
        abc()
      else
        abnc()
    else
      if c then
        anbc()
      else
        anbnc()
  else
    if b then
      if c then
        nabc()
      else
        nabnc()
    else
      if c then
        nanbc()
      else
        nanbnc()




# Заключение

В этой части рассмотрены некоторые соображения, которые позволяют подойти к тестам с рациональных позиций. Если во главу угла поставлено качество программного обеспечения, то тесты являются лишь одним из компонентов процесса разработки. Значительно большее влияние на качество могут оказать типы данных.

Под качеством ПО понимается оптимизация целевой функции при соблюдении ограничений (соответствие требованиям). Причём в качестве целевой функции может выступать и стоимость разработки. А так как на разработку и поддержку тестов уходят усилия, то небезынтересен вопрос о том, каким образом обеспечить качество ПО при минимальном количестве тестов. Например, за счёт использования типов данных, исключающих некоторые классы ошибок.
