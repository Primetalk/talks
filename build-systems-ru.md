Tags: continuous deployment, разработка ПО, CI/CD, DevOps, системы сборки, gradle
PAA: ??? 
Labels:  gradle, kotlin

# Сборка (CI/CD) проектов

Во многих проектах сборке отводится незначительная роль. Основные усилия команда
сосредоточивает на разработке кода. В больших гетерогенных проектах 
сборка оказывается достаточно сложной и к ней вполне можно подходить как 
к самостоятельному проекту.

В этой заметке мы рассмотрим, по каким критериям мы выбирали инструментарий и 
каким образом этот инструментарий используем.

### План

1. Введение
2. Часть 1. Выбор инструмента (make/shell, ant, maven, sbt, gradle/groovy, gradle/kotlin)
3. Часть 2. Особенности gradle.kts
4. Заключение

- Во многих прежних проектах - костыли

#### JVM
- Каждый jar-ник - в artifactory
- сборка Java-проектов

#### выбор систем сборки
- классификация систем сборки??
- эволюция систем сборки
- cmake - генерация скриптов сборки??
- использование gradle, gradle.kts, плагинов
- sbt - в чём проблема - мутабельная модель, вообще говоря
  
#### про gradle/kotlin
- порог входа в gradle.kts
- + переключение groovy/kts - больно
- + документация: родная - высочайшего класса. Стэк оверфлоу - на груви. Гугл не позволяет найти на kotlin'е. Обнаруживаемость (discoverability) - не очень
- удачный кейс?
- kts - поддержка intelli-sense. 
- + gradle-скрипты - ужас-ужас.
- грабли
- как не надо писать
- + пример DSL из косогор-плагина
- + котлин позволяет, в принципе, неплохой DSL создавать.
- + wrapper - позволяет не задумываться о сборке разработчикам из других областей.
- + кросс-платформенность
- что особенно нравится/бесит: 
  - скорость работы
  - быстро, как грэдл - один из selling-point'ов.
  - неудобно вызывать shell-команды
- точки роста - что было бы хорошо допилить
- модель, на которой работает gradle - таски, source set'ы, деревья файлов, проекты, 
  свойства
- ленивость, доведённая до высшей точки - даже таски не создаются.

- версионирование?? поддержка semver??

- tips - как обеспечить инкрементную сборку (и пожелание авторам добавить проперти в инкрементную сборку - уже сделано?)

- в чём главный дефект скриптов конфигурирования билда. И почему лучше было бы перейти 
  полностью на котлин
- манипулирование моделью проекта с помощью скриптов или как часть плагина
- поддержка скриптов

### Введение

Модель сборки - DAG (направленный граф без циклов). 
Важными частями модели грэдл являются
- задачи (Task) - выполняемые операции, узел графа зависимостей, имя+описание, ;
- проект - логическая единица организации кода, совокупность и scope задач, 
  точка подключения плагинов
- плагин - возможность или фича, добавляемая в проект. Среди прочего - набор задач. 
- зависимости, проверка up-to-date

<cut/>

### Выбор инструмента

При старте проекта иногда бывает можно оценить, насколько сложной окажется интеграция проекта.
В нашем случае оказалось, что требуется собирать несколько модулей node.js, несколько go-lang, 
осуществлять развёртывание нескольких модулей terraform (и ни одного jvm-модуля).

В других аналогичных проектах, развивавшихся "органически", сборка осуществлялась с 
использованием `make`, а в скриптах сборки использовались `bash`, `perl`, 
`curl`, `php` и др. Механизм сборки было трудно поддерживать, производительность
оставляла желать лучшего и ряд возможностей не был реализован.

Для нового проекта мы задумались, какой инструмент взять за основу системы 
сборки. Оценили такие варианты:

- make,
- ant,
- maven,
- sbt,
- gradle/groovy,
- gradle/kotlin.

Почему для сборки используется не структурированный подход 
(процедура вызывает другие процедуры, а затем пользуется результатами), а 
[направленный граф](https://ru.wikipedia.org/wiki/Ориентированный_ациклический_граф) 
([DAG](https://en.wikipedia.org/wiki/Directed_acyclic_graph))? Это связано 
с желанием выполнять только те действия, которые необходимы для ближайшей задачи.

#### Make

Плюсы
- наличие компетенции;
- похож на shell;

Минусы
- идеологически древняя модель;
- запутанный синтаксис;
- глобальные состояния;
- нет поддержки проектов, плагинов;

#### Ant

Похож на make, только на платформе JVM. Скрипт записывается в `.xml`. 
Детально не рассматривали, т.к. на JVM есть более современные преемники.

#### Maven

Плюсы
- наличие компетенции;
- развитая модель проектов и подпроектов;
- поддержка плагинов;
- декларативная модель;
- maven wrapper.

Минусы
- слабая поддержка других технологий;
- трудоёмкость реализации плагинов;
- отсутствие возможности реализации императивных скриптов;
- жёсткая структура жизненного цикла.

Отсутствие императивных скриптов является и плюсом и минусом. С одной стороны, 
декларативный подход обеспечивает жёсткое разделение кода и модели, с другой стороны,
задачи сборки зачастую требуют отдельных вставок императивной логики.

#### Sbt

Плюсы
- развитый язык;
- поддержка плагинов и императивных вставок;
- поддержка инкрементной сборки;
- поддержка непрерывной сборки по мере изменения;
- параллельное исполнение;

Минусы
- неожиданная модель (вместо задач - "настройки");
- неявные зависимости через `.value`;
- слабая поддержка других технологий (go, node.js);
- неожиданный синтаксис;

#### gradle

Плюсы
- поддержка модели проектов;
- поддержка декларативного (основанного на модели) и императивного подхода одновременно;
- поддержка инкрементной сборки;
- в основе модели исполнения - DAG задач;
- превосходная документация (для двух диалектов сразу);
- очень быстрая работа (даже определения тасков выполняются 
  только в случае необходимости);
- кросс-платформенность - работает везде;
- gradle wrapper - небольшой скрипт для загрузки и запуска gradle правильной версии;

Минусы
- отсутствие компетенции;
- нет естественных барьеров против засилья императивного кода; необходимы дисциплина и 
  следование рекомендованным практикам;
- не поддерживаются иные механизмы зависимостей, кроме JVM (maven, ivy2);


##### Выбор диалекта - gradle/groovy или gradle/kotlin

Изначально gradle использовался с помощью groovy-DSL. В дальнейшем был разработан 
DSL на основе Kotlin'а.

Плюсы Kotlin'а
- компилируемый строго-типизированный язык:
  - защита от ошибок на этапе компиляции,
  - поддержка intelli-sense,
  - безопасный рефакторинг,
- хорошая поддержка DSL,
- простой синтаксис, меньше бойлерплейта, по сравнению с Java, 
- достаточно много сахара,

Минусы
- на просторах интернета большинство примеров - для groovy, иногда бывает трудно сообразить,
  как переписать пример на kotlin'е.
- немного повышается порог входа в связи с необходимостью освоения нового языка,

#### gradle/kotlin vs make

Ниже приведены сравнительные преимущества gradle/kotlin по отношению к make:

Преимущества:
- компилируемый строго-типизированный язык;
- высочайшая производительность;
- развитая модель;
- согласованный синтаксис полноценного языка программирования;


### Применение gradle/kotlin

В конце концов остановились на gradle/kotlin.

#### Общие сведения о работе gradle

Грэдл вначале ищет `settings.gradle.kts`, компилирует и исполняет его, чтобы 
выяснить, какие подпроекты и где расположены (фаза "инициализации"). Компиляция здесь и в других точках -
только по мере необходимости, если файл не менялся, то будет использована последняя
скомпилированная версия.

Затем для всех проектов находятся скрипты сборки и тоже компилируются (по мере необходимости) и 
исполняются (только те проекты, которые нужны для целевой задачи) (фаза "конфигурации").

Наконец, по построенному частичному графу зависимостей между задачами определяется 
подграф, который необходим для достижения целей текущей целевой задачи. Для задач
выясняется условие up-to-date, то есть, надо ли выполнять задачу или нет. 
И потом выполняются те задачи, которые нужны (фаза "исполнения").

![Граф задач (из документации)](https://docs.gradle.org/current/userguide/img/task-dag-examples.png)

#### Общие соображения, как лучше

##### `buildSrc`

Настройка сборки проекта в основном делается в скриптах `build.gradle.kts`. 
Среди прочего эти скрипты позволяют создавать ad-hoc задачи и выполнять
произвольный код. Если не соблюдать самодисциплину и не следовать рекомендациям,
то скрипт сборки быстро превращается в макаронный код. 

Создание тасков и использование исполняемого кода 
внутри скрипта сборки следует считать исключением и временной мерой, и помнить, 
что поддержка проекта сборки с императивной логикой в скриптах сборки крайне затруднительна.

Основным местом для императивной логики и пользовательских задач следует считать
вспомогательный проект `buildSrc`. Этот проект компилируется автоматически
и добавляется в зависимости скрипта сборки. Так что всё, что в нём объявлено,
будет доступно для использования в скриптах.

В самом скрипте сборки остаются объявления плагинов, их конфигурации,

##### Плагины

Для разных типов проектов (go, node.js, terraform) имеет смысл создавать плагины.
Имеющиеся плагины (например, kosogor для terraform'а) можно использовать, но 
некоторых возможностей не хватает.

Плагин можно делать в `buildSrc`, либо в качестве отдельных проектов для 
повторного использования.

Плагин можно рассмотреть как совокупность следующих элементов:
- декларативная конфигурация;
- скрипт создания задач на основе конфиуграции;
- возможность однократного подключения к отдельному проекту и 
  настройки подключенного экземпляра;

Типичный плагин может выглядеть так:

```kotlin
class MyPlugin: Plugin<Project> {
    override fun apply(project: Project) {
        project.tasks.register("mytask"){
            it.doLast{
                println("mytask executed")
            }
        }    
    }
}
```

##### DSL

Кроме собственно плагинов, похожего результата можно достичь просто вызывая заранее 
написанные функции, создающие задачи.

В качестве примера можно посмотреть, как в [библиотеке kosogor](https://github.com/TanVD/kosogor/tree/master/kosogor-terraform)
сделано добавление задач с помощью DSL.
```kotlin
terraform {
    config {
        tfVersion = "0.11.11"
    }
    root("example", File(projectDir, "terraform"))
}
```

Внешняя функция `terraform` выглядит как extension для типа `Project`:
```kotlin
@TerraformDSLTag
fun Project.terraform(configure: TerraformDsl.() -> Unit) {
    terraformDsl.project = this
    terraformDsl.configure()
}
```

То есть код, который напишет пользователь внутри `{}` будет выполнен на объекте типа 
`TerraformDsl`. Например, [метод `root`](https://github.com/TanVD/kosogor/blob/master/kosogor-terraform/src/main/kotlin/tanvd/kosogor/terraform/TerraformDsl.kt#L131) 
создаёт задачи с использованием конфигурации и переданного в метод имени:
```kotlin
    @TerraformDSLTag
    fun root(name: String, dir: File, enableDestroy: Boolean = false, targets: LinkedHashSet<String> = LinkedHashSet(), workspace: String? = null) {
        val lint = project!!.tasks.create("$name.lint", LintRootTask::class.java) { task ->
            task.group = "terraform.$name"
            task.description = "Lint root $name"
            task.root = dir
        }
        // ...
    }
```

Использование в Kotlin методов, принимающих последним параметром функции вида `Type.()->Unit`, 
позволяет сделать DSL, который выглядит достаточно элегантно и удобно. В чём-то это предоставляет 
больше гибкости и удобства, чем плагины.

##### Tips&tricks

###### Почему важно добиваться инкрементности билда

Сборка проекта может запускаться сотни раз в день. 
Если при этом билд-скрипт делает лишнюю работу, 
то это может выливаться в заметные потери времени. В запущенных случаях, если, например, сборка 
занимает 10-30 минут, работа существенно затрудняется и вызывает раздражение.
Если сборка выполняется в облаке и производит развёртывание в нескольких конфигурациях,
то длительная работа скрипта может приводить и к повышению расходов.

Свойство "инкрементности" не появляется само по себе. Инкрементным билд становится в том случае, есл
все задачи поддерживают это свойство. В идеальном случае повторный запуск последней команды грэдл
должен происходить за секунду, т.к. все задачи будут пропущены.

###### Автоматические зависимости на основе свойств и файлов

Если задача Б зависит от результата задачи А, то можно так сконфигурировать эти задачи, 
что грэдл догадается, что надо выполнить задачу А, даже без явного указания зависимости.

Для этого в gradle предусмотрен целый механизм properties и providers 
(в других языках/системах похожим образом можно использовать монады).
На этапе конфигурирования некоторые значения должны быть спрятаны внутрь провайдеров.
Если одно значение вычисляется (или в частном случае равно) на основе другого значения,
то у провайдера источника вызывается `.map` или `.flatMap` и внутри лямбды можно оперировать
будущим значением.

Пример
```kotlin
class TaskA: DefaultTask() {
    @OutputFile
    val result = project.objects.fileProperty()
    init {
        result.convention(project.buildDir.file("result.txt"))
    }
}
class TaskB: DefaultTask() {
    @InputFile
    val input = project.objects.fileProperty()
   
    @Action
    fun taskB() {
        println(input.get().asFile.absolutePath)
    }
}
```
В скрипте зависимость между этими задачами можно не объявлять явно, при условии, что связаны свойства:

```kotlin
val taskA = tasks.register<TaskB>("taskA") {
    output.set(file("other.txt"))
}
tasks.register<TaskB>("taskB") {
    input.set(taskA.result)
}
```
Теперь, при вызове taskB будет проверятся актуальность задачи А и, в случае необходимости, выполняться.

###### Использование файлов в качестве сигналов, которые переживают вызовы

При выполнении чистых побочных эффектов (например, развёртывании в облако), 
которые не отражаются естественным образом в файлах, грэдл не может проверить, надо ли
выполнять задачу или не надо. В результате соответствующая задача будет выполняться всякий раз.

Чтобы помочь грэдлу, можно по окончании выполнения задачи создавать файл `taskB.done`, и
указать, что этот файл является выходным для задачи.

###### Перезапуск локального сервиса, только если изменился исполняемый файл

Пусть у нас есть задача сборки, которая производит исполняемый файл
```kotlin
class BuildNative(objects: ObjectFactory): DefaultTask() {
    @OutputFile
    val nativeBinary: FileProperty = objects.fileProperty()
    init {
        nativeBinary.convention("binary")
    }
    @TaskAction
    fun build() {
        // ...
    }
}
```
Запуск сервиса производится созданием процесса с именем этого исполняемого файла.
```kotlin
open class StartService(objects: ObjectFactory): DefaultTask() {
    @InputFile
    val nativeBinary: FileProperty = objects.fileProperty()
    @OutputFile
    val pidFile: FileProperty = objects.fileProperty()
    init {
        nativeBinary.convention("binary")
        pidFile.convention("binary.pid")
    }
    @TaskAction
    fun start() {
        pidFile.get().asFile.writeText(
                Process(nativeBinary.get().asFile.absolutePath).start()
        )// несколько упрощённо
    }
}
```

Теперь мы можем объявить задачу перезапуска, которая не будет выполняться, если исполняемый файл не изменился
```kotlin
class ServiceStarted(objects: ObjectFactory): StartService(objects) {
    @TaskAction
    fun restartIfNeeded() {
        if(pidFile.get().asFile.exists()) {
            kill(pidFile.get().asFile.readText())
        }        
        start()
    }
}
```

##### Непрошенные советы

1. **Прочитайте документацию**. Документация gradle может служить образцом для подражания. 
2. **Поймите модель gradle**. Множество вопросов отпадёт само по себе, если разобраться 
   с базовой моделью gradle.
3. **Используйте buildSrc**. При сборке проектов зачастую требуется добавить 
   отдельные вспомогательные задачи. Помещайте такие задачи в `buildSrc`.    
   
### Заключение

В этом посте мы рассмотрели реализацию инструментария сборки проекта и CI/CD
на основе gradle/kotlin. В сравнении, например, с реализацией сборки проекта 
на основе make/shell, такой подход обладает следующими преимуществами:

- высочайшая скорость работы. Команда Gradle прикладывает постоянные усилия 
  в направлении улучшения скорости и в реализации инструментов, способствующих
  реализации высокоскоростных скриптов.
- унификация языка. Все задачи решаются в рамках одного языка - Kotlin.
  Нет необходимости изучать особенности режимов make, различия версий shell-интерпретаторов,
  варианты обработки параметров командной строки в разных утилитах,
  отдельные языки программирования для шаблонов (php?, perl?).
- компилируемый проект. За счёт использования современного языка со статической 
  типизацией, исключается множество классов ошибок, характерных для скриптовых языков.
- декларативная модель проектов и плагинов поверх декларативного орграфа задач.
- возможность комбинирования декларативного и императивного подхода.
  Несмотря на то, что декларативный подход обеспечивает понятность и чистоту кода,
  лёгкость поддержки, возможности комбинирования компонентов, императивный подход 
  может оказаться незаменимым в силу своей гибкости. Новые задачи можно вначале
  решить императивным способом (ad-hoc), а затем обобщить и выделить в форме 
  декларативных конфигурируемых плагинов.
- платформа JVM. На этой платформе есть полный набор библиотек на все случаи жизни.

Из недостатков можно отметить 
- необходимость соблюдения самодисциплины при разработке скриптов сборки во 
  избежание макаронного кода. В gradle, насколько мне известно, отсутствуют 
  механизмы защиты от чрезмерного использования императивного кода.
- необходимость предпринимать усилия для того, чтобы каждая задача поддерживала
  инкрементную сборку.

### Благодарности

Хотелось бы поблагодарить ... за конструктивную критику черновика статьи.
