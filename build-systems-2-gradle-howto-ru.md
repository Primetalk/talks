Tags: continuous deployment, разработка ПО, CI/CD, DevOps, системы сборки, gradle
PAA: ??? 
Labels:  gradle, kotlin

# Сборка (CI/CD) не-JVM проектов с использованием gradle/kotlin

Во многих проектах сборке отводится незначительная роль. Основные усилия команда
сосредоточивает на разработке кода. В больших гетерогенных проектах 
сборка оказывается достаточно сложной и к ней вполне можно подходить как 
к самостоятельному проекту.

В [предыдущей заметке](build-systems-1-selection-ru.md) мы рассмотрели, по каким критериям 
мы выбирали инструментарий, и почему остановились на gradle/kotlin, 
а в этой заметке — каким образом используем gradle/kotlin для автоматизации сборки не-JVM 
проектов.


## Введение

Gradle для JVM-проектов является общепризнанным инструментом и не нуждается в 
дополнительных рекомендациях. Для проектов за пределами JVM он также используется. 
Например, в официальной документации описаны сценарии использования для C++ и Swift проектов.
Мы используем gradle для автоматизации сборки, тестирования и развёртывания
гетерогенного проекта, включающего модули на node.js, go, terraform.

<cut/>

## Использование git submodule для организации интеграционной сборки

Каждый модуль большого проекта разрабатывается отдельной командой в своём репозитории.
В то же время, хотелось бы работать с большим проектом как с одной целостной системой: 
- осуществлять интеграционное тестирование,
- выполнять развёртывание в различных конфигурациях,
- выпускать согласованные релизы,
- и т.д.

Достаточно удобно подключить репозитории проектов в один репозиторий с помощью git submodule.
При этом мы имеем возможность работать с одной сквозной версией всех подпроектов. Каждый
из подпроектов будет зафиксирован на одном коммите. В случае реализации функциональности,
затрагивающей несколько подпроектов, мы можем создать ветку в проекте верхнего уровня и для
каждого подпроекта указать подветку, которую следует использовать. Тем самым появляется
возможность согласованной разработки и тестирования именно этой новой функциональности без
интерференции со стороны других функциональных возможностей.

При развёртывании используется имя ветки проекта верхнего уровня для идентификации
ресурсов, относящихся к этой ветке. Такая схема идентификации позволяет непосредственно 
перед удалением ветки автоматически удалить все связанные ресурсы.

## Общие сведения о работе gradle

Грэдл вначале ищет `settings.gradle.kts`, компилирует и исполняет его, чтобы 
выяснить, какие подпроекты и где расположены (фаза "инициализации"). Компиляция здесь и в других точках -
только по мере необходимости, если файл и зависимости не менялись, то будет использована последняя
скомпилированная версия.

Затем для всех проектов находятся скрипты сборки и тоже компилируются (по мере необходимости) и 
исполняются (только те проекты, которые нужны для целевой задачи) (фаза "конфигурации").

По построенному частичному графу зависимостей между задачами определяется 
подграф, который необходим для достижения целей текущей целевой задачи. Для задач
выясняется условие up-to-date, то есть, надо ли выполнять задачу или нет. 
И потом выполняются те задачи, которые нужны (фаза "исполнения").

Основной моделью представления системы сборки является направленный граф без циклов (DAG). 
Узлами графа служат задачи, между которыми устанавливаются зависимости. Частично зависимости
выводятся грэдлом с использованием свойств задач. Граф задач в целом очень похож на структуру,
используемую в make.

![Граф задач (из документации)](https://docs.gradle.org/current/userguide/img/task-dag-examples.png)

Код сборки на основе только лишь графа задач представляет собой 
трудно поддерживаемый императивный скрипт. Для того, чтобы упорядочить аналогичные 
наборы задач, относящиеся к разным модулям, в грэдл вводятся понятия проектов и плагинов. 
Проектом называется модуль, представляющий часть исходного кода большого проекта, а плагином — 
повторно используемый набор взаимосвязанных задач, которые инстанцируются для конкретного
проекта. Похожие понятия используются и в maven.

### DSL (domain-specific language)

Грэдл использует гибкий подход к организации скрипта сборки на основе идеи встроенного 
специализированного языка. В основной язык (groovy или kotlin) добавляются функции, объекты 
и классы, спроектированные специальным образом, чтобы при их использовании получались легко
воспринимаемые скрипты, похожие на декларативное описание проекта. То есть, несмотря на то,
что скрипт сборки представляет собой императивную программу, он может выглядеть как
декларативное описание конфигурации плагинов и структуры проекта.

В этом подходе кроется как сила/удобство gradle, так и уязвимость к чрезмерному использованию
императивных возможностей. На данный момент выглядит так, что единственное средство — 
самодисциплина.

## Общие соображения, как лучше использовать gradle/kotlin

### `buildSrc`

Настройка сборки проекта в основном делается в скриптах `build.gradle.kts`. 
Среди прочего эти скрипты позволяют создавать ad-hoc задачи и выполнять
произвольный код. Если не соблюдать самодисциплину и не следовать рекомендациям,
то скрипт сборки быстро превращается в макаронный код. 

Создание тасков и использование исполняемого кода 
внутри скрипта сборки следует считать исключением и временной мерой, и помнить, 
что поддержка проекта сборки с императивной логикой в скриптах сборки крайне затруднительна.

Основным местом для императивной логики и пользовательских задач следует считать
вспомогательный проект `buildSrc`. Этот проект компилируется автоматически
и добавляется в зависимости скрипта сборки. Так что всё, что в нём объявлено,
будет доступно для использования в скриптах.

В самом скрипте сборки остаются объявления плагинов, их конфигурации и настройки проекта.

### Плагины

Для разных типов проектов (go, node.js, terraform) имеет смысл создавать плагины.
Имеющиеся плагины (например, kosogor для terraform'а) можно использовать, но 
некоторых возможностей не хватает.

Плагин можно делать в `buildSrc`, либо в качестве отдельных проектов для 
повторного использования. Если используются отдельные проекты, то либо надо подключать 
эти проекты в качестве included build, либо публиковать артефакты
в развёрнутом репозитории (Artifactory, Nexus).

Плагин можно рассмотреть как совокупность следующих элементов:
- декларативная конфигурация;
- скрипт создания задач на основе конфиуграции;
- возможность однократного подключения к отдельному проекту и 
  настройки подключенного экземпляра;

Типичный плагин может выглядеть так:

```kotlin
class MyPlugin: Plugin<Project> {
    override fun apply(project: Project) {
        project.tasks.register("mytask"){
            it.doLast{
                println("mytask executed")
            }
        }    
    }
}
```

##### DSL

Кроме собственно плагинов, похожего результата можно достичь просто вызывая заранее 
написанные функции, создающие задачи.

В качестве примера можно посмотреть, как в [библиотеке kosogor](https://github.com/TanVD/kosogor/tree/master/kosogor-terraform)
сделано добавление задач с помощью DSL.
```kotlin
terraform {
    config {
        tfVersion = "0.11.11"
    }
    root("example", File(projectDir, "terraform"))
}
```

Внешняя функция `terraform` выглядит как extension для типа `Project`:
```kotlin
@TerraformDSLTag
fun Project.terraform(configure: TerraformDsl.() -> Unit) {
    terraformDsl.project = this
    terraformDsl.configure()
}
```

То есть код, который напишет пользователь внутри `{}` будет выполнен на объекте типа 
`TerraformDsl`. Например, [метод `root`](https://github.com/TanVD/kosogor/blob/master/kosogor-terraform/src/main/kotlin/tanvd/kosogor/terraform/TerraformDsl.kt#L131) 
создаёт задачи с использованием конфигурации и переданного в метод имени:
```kotlin
    @TerraformDSLTag
    fun root(name: String, dir: File, enableDestroy: Boolean = false, targets: LinkedHashSet<String> = LinkedHashSet(), workspace: String? = null) {
        val lint = project!!.tasks.create("$name.lint", LintRootTask::class.java) { task ->
            task.group = "terraform.$name"
            task.description = "Lint root $name"
            task.root = dir
        }
        // ...
    }
```

Использование в Kotlin методов, принимающих последним параметром функции вида `Type.()->Unit`, 
позволяет сделать DSL, который выглядит достаточно элегантно и удобно. В чём-то это предоставляет 
больше гибкости и удобства, чем плагины.

##### Tips&tricks

###### Почему важно добиваться инкрементности билда

Сборка проекта может запускаться сотни раз в день. 
Если при этом билд-скрипт делает лишнюю работу, 
то это может выливаться в заметные потери времени. В запущенных случаях, если, например, сборка 
занимает 10-30 минут, работа существенно затрудняется и вызывает раздражение.
Если сборка выполняется в облаке и производит развёртывание в нескольких конфигурациях,
то длительная работа скрипта может приводить и к повышению расходов.

Свойство "инкрементности" не появляется само по себе. Инкрементным билд становится в том случае, есл
все задачи поддерживают это свойство. В идеальном случае повторный запуск последней команды грэдл
должен происходить за секунду, т.к. все задачи будут пропущены.

###### Автоматические зависимости на основе свойств и файлов

Если задача Б зависит от результата задачи А, то можно так сконфигурировать эти задачи, 
что грэдл догадается, что надо выполнить задачу А, даже без явного указания зависимости.

Для этого в gradle предусмотрен целый механизм properties и providers 
(в других языках/системах похожим образом можно использовать монады).
На этапе конфигурирования некоторые значения должны быть спрятаны внутрь провайдеров.
Если одно значение вычисляется (или в частном случае равно) на основе другого значения,
то у провайдера источника вызывается `.map` или `.flatMap` и внутри лямбды можно оперировать
будущим значением.

Пример
```kotlin
class TaskA: DefaultTask() {
    @OutputFile
    val result = project.objects.fileProperty()
    init {
        result.convention(project.buildDir.file("result.txt"))
    }
}
class TaskB: DefaultTask() {
    @InputFile
    val input = project.objects.fileProperty()
   
    @Action
    fun taskB() {
        println(input.get().asFile.absolutePath)
    }
}
```
В скрипте зависимость между этими задачами можно не объявлять явно, при условии, что связаны свойства:

```kotlin
val taskA = tasks.register<TaskB>("taskA") {
    output.set(file("other.txt"))
}
tasks.register<TaskB>("taskB") {
    input.set(taskA.result)
}
```
Теперь, при вызове taskB будет проверятся актуальность задачи А и, в случае необходимости, выполняться.

###### Использование файлов в качестве сигналов, которые переживают вызовы

При выполнении чистых побочных эффектов (например, развёртывании в облако), 
которые не отражаются естественным образом в файлах, грэдл не может проверить, надо ли
выполнять задачу или не надо. В результате соответствующая задача будет выполняться всякий раз.

Чтобы помочь грэдлу, можно по окончании выполнения задачи создавать файл `taskB.done`, и
указать, что этот файл является выходным для задачи.

###### Перезапуск локального сервиса, только если изменился исполняемый файл

Пусть у нас есть задача сборки, которая производит исполняемый файл
```kotlin
class BuildNative(objects: ObjectFactory): DefaultTask() {
    @OutputFile
    val nativeBinary: FileProperty = objects.fileProperty()
    init {
        nativeBinary.convention("binary")
    }
    @TaskAction
    fun build() {
        // ...
    }
}
```
Запуск сервиса производится созданием процесса с именем этого исполняемого файла.
```kotlin
open class StartService(objects: ObjectFactory): DefaultTask() {
    @InputFile
    val nativeBinary: FileProperty = objects.fileProperty()
    @OutputFile
    val pidFile: FileProperty = objects.fileProperty()
    init {
        nativeBinary.convention("binary")
        pidFile.convention("binary.pid")
    }
    @TaskAction
    fun start() {
        pidFile.get().asFile.writeText(
                Process(nativeBinary.get().asFile.absolutePath).start()
        )// несколько упрощённо
    }
}
```

Теперь мы можем объявить задачу перезапуска, которая не будет выполняться, если исполняемый файл не изменился
```kotlin
class ServiceStarted(objects: ObjectFactory): StartService(objects) {
    @TaskAction
    fun restartIfNeeded() {
        if(pidFile.get().asFile.exists()) {
            kill(pidFile.get().asFile.readText())
        }        
        start()
    }
}
```

##### Непрошенные советы

1. **Прочитайте документацию**. Документация gradle может служить образцом для подражания. 
2. **Поймите модель gradle**. Множество вопросов отпадёт само по себе, если разобраться 
   с базовой моделью gradle.
3. **Используйте buildSrc**. При сборке проектов зачастую требуется добавить 
   отдельные вспомогательные задачи. Помещайте такие задачи в `buildSrc`.    
   
### Заключение

В этом посте мы рассмотрели реализацию инструментария сборки проекта и CI/CD
на основе gradle/kotlin. В сравнении, например, с реализацией сборки проекта 
на основе make/shell, такой подход обладает следующими преимуществами:

- высочайшая скорость работы. Команда Gradle прикладывает постоянные усилия 
  в направлении улучшения скорости и в реализации инструментов, способствующих
  реализации высокоскоростных скриптов.
- унификация языка. Все задачи решаются в рамках одного языка — Kotlin.
  Нет необходимости изучать особенности режимов make, различия версий shell-интерпретаторов,
  варианты обработки параметров командной строки в разных утилитах,
  отдельные языки программирования для шаблонов (php?, perl?).
- компилируемый проект. За счёт использования современного языка со статической 
  типизацией, исключается множество классов ошибок, характерных для скриптовых языков.
- декларативная модель проектов и плагинов поверх декларативного орграфа задач.
- возможность комбинирования декларативного и императивного подхода.
  Несмотря на то, что декларативный подход обеспечивает понятность и чистоту кода,
  лёгкость поддержки, возможности комбинирования компонентов, императивный подход 
  может оказаться незаменимым в силу своей гибкости. Новые задачи можно вначале
  решить императивным способом (ad-hoc), а затем обобщить и выделить в форме 
  декларативных конфигурируемых плагинов.
- платформа JVM. На этой платформе есть полный набор библиотек на все случаи жизни.

Из недостатков можно отметить 
- необходимость соблюдения самодисциплины при разработке скриптов сборки во 
  избежание макаронного кода. В gradle, насколько мне известно, отсутствуют 
  механизмы защиты от чрезмерного использования императивного кода.
- необходимость предпринимать усилия для того, чтобы каждая задача поддерживала
  инкрементную сборку.

### Благодарности

Хотелось бы поблагодарить Антона Поцюса, @Starcounter, Алексея Жукова
за конструктивную критику черновика статьи.



#### JVM
- Каждый jar-ник — в artifactory
- сборка Java-проектов

#### выбор систем сборки
- классификация систем сборки??
- эволюция систем сборки
- cmake — генерация скриптов сборки??
- использование gradle, gradle.kts, плагинов
- sbt — в чём проблема — мутабельная модель, вообще говоря

#### про gradle/kotlin
- порог входа в gradle.kts
- + переключение groovy/kts — больно
- + документация: родная — высочайшего класса. Стэк оверфлоу — на груви. Гугл не позволяет найти на kotlin'е. Обнаруживаемость (discoverability) — не очень
- удачный кейс?
- kts — поддержка intelli-sense.
- + gradle-скрипты — ужас-ужас.
- грабли
- как не надо писать
- + пример DSL из косогор-плагина
- + котлин позволяет, в принципе, неплохой DSL создавать.
- + wrapper — позволяет не задумываться о сборке разработчикам из других областей.
- + кросс-платформенность
- что особенно нравится/бесит:
  — скорость работы
  — быстро, как грэдл — один из selling-point'ов.
  — неудобно вызывать shell-команды
- точки роста — что было бы хорошо допилить
- модель, на которой работает gradle — таски, source set'ы, деревья файлов, проекты,
  свойства
- ленивость, доведённая до высшей точки — даже таски не создаются.

- версионирование?? поддержка semver??

- tips — как обеспечить инкрементную сборку (и пожелание авторам добавить проперти в инкрементную сборку — уже сделано?)

- в чём главный дефект скриптов конфигурирования билда. И почему лучше было бы перейти
  полностью на котлин
- манипулирование моделью проекта с помощью скриптов или как часть плагина
- поддержка скриптов
