
# Бестолковые тесты versus качественное ПО. Часть 2. Что делать

В [первой части](/part1) мы рассмотрели примеры тестов, из которых не все одинаково полезны. Здесь попробуем разобраться, что с этими тестами не так, и как всё-таки обеспечить качество ПО.

- [Бестолковые тесты versus качественное ПО. Часть 2. Что делать](#бестолковые-тесты-versus-качественное-по-часть-2-что-делать)
  - [Что делать?](#что-делать)
    - [Качество ПО](#качество-по)
    - [Уровни абстракции](#уровни-абстракции)
    - ["Прямолинейность" кода (цикломатическая сложность)](#прямолинейность-кода-цикломатическая-сложность)
      - [1. Тестовые данные и "прямолинейность" кода](#1-тестовые-данные-и-прямолинейность-кода)
      - [2. Типы данных, уменьшающие цикломатическую сложность](#2-типы-данных-уменьшающие-цикломатическую-сложность)
      - [3. "Распрямление" if-boolean и match-enum](#3-распрямление-if-boolean-и-match-enum)
      - [4. "Рельсовое программирование" и цикломатическая сложность](#4-рельсовое-программирование-и-цикломатическая-сложность)
      - [5. Циклы vs. map/flatMap](#5-циклы-vs-mapflatmap)
    - [Задание функции таблицей и алгоритмом](#задание-функции-таблицей-и-алгоритмом)
    - [Эквивалентность функций](#эквивалентность-функций)
      - [Доказательство эквивалентности](#доказательство-эквивалентности)
      - [Гарантии корректности "по построению"](#гарантии-корректности-по-построению)
      - [Доказательство сделанной работы с помощью типов. 1](#доказательство-сделанной-работы-с-помощью-типов-1)
      - [Доказательство сделанной работы с помощью типов. 2](#доказательство-сделанной-работы-с-помощью-типов-2)
      - [Увеличение сложности программ](#увеличение-сложности-программ)
    - [Классификация ошибок](#классификация-ошибок)
    - [Системный подход](#системный-подход)
    - [Пример цепочки действий](#пример-цепочки-действий)
    - [Взаимодействие с подсистемами, обладающими состоянием (statful)](#взаимодействие-с-подсистемами-обладающими-состоянием-statful)
      - [Пример разделения сценария](#пример-разделения-сценария)
    - [Применимость юнит-тестов](#применимость-юнит-тестов)
      - [Воспроизведение известных багов](#воспроизведение-известных-багов)
      - [Одиночный тест "прямолинейного" кода](#одиночный-тест-прямолинейного-кода)
      - [Smoke-тест ("Дымовой" тест)](#smoke-тест-дымовой-тест)
      - [Набор тестов-индикаторов на каждое требование](#набор-тестов-индикаторов-на-каждое-требование)
      - [Чего не надо ожидать от юнит-тестирования](#чего-не-надо-ожидать-от-юнит-тестирования)
      - [Ограниченная польза юнит-тестов](#ограниченная-польза-юнит-тестов)
- [Заключение](#заключение)


## Что делать?

Во-первых, раз тесты предполагается использовать для улучшения качества, надо определиться с критериями качества программного обеспечения. Ведь, если ориентироваться на % покрытия, то ряд вышеприведённых примеров будет разумным решением. 
Во-вторых, хорошо бы разобраться с тем, чем отличается алгоритмическая функция от табличной на фундаментальном уровне.
В-третьих, понять, как преобразовать требования к ПО в работающий код с использованием уровней абстракции.
В-четвёртых, проанализировать типы ошибок и понять роль тестов/типов в сфере защиты от ошибок. Что разумно требовать от тестов, и чего ожидать не стоит.
В-пятых, понять, какое отношение имеет системный подход к юнит-тестированию.

### Качество ПО

Качественная программа — (1) **достигает** (2) **требуемого результата** с соблюдением (3) заданных **ограничений** и (4) **минимизирует** (5) **целевую функцию**. Причём *ограничения* и *целевая функция* могут относиться не к самой программе, а к процессу её разработки.

Типичные ограничения (3):
- язык программирования/платформа;
- набор библиотек;
- стиль кодирования;
- ограничения предметной области (например, секретность);
- производительность (не ниже уровня);
- способности (знания, навыки) команды;
- ...

В качестве целевой функции (5) можно рассматривать:
- финансовые показатели:
  - инвестиции (время/стоимость разработки);
  - стоимость владения;
  - стоимость (потенциальная) последующего развития/расширения функционала;
- срок готовности ПО;
- количество строк кода;
- количество багов в течение опытного периода эксплуатации;
- производительность (время — деньги);
- задержки (latency);
- "степень удовлетворённости";
- ...

Сами тесты обычно не входят ни в целевую функцию, ни в ограничения. Т.е. тесты не являются целью разработки ПО, а могут служить средством достижения каких-либо целей. Например, с помощью теста можно в какой-то степени проверить, достигает ли программа требуемого результата при определённых входных значениях.

Иногда (на мой взгляд, ошибочно) тесты включают в ограничения: "покрытие тестами должно быть не ниже 70%" или "все возвращаемые ошибки должны быть проверены". А иногда (ещё, на мой взгляд, более ошибочно) — в целевую функцию: "код максимально покрыт тестами".

Можно ли выразить требуемый результат (2) в форме приёмочных тестов? Несмотря на общую веру в приёмочные тесты, требуемый результат, вообще говоря, невозможно описать одними лишь тестами. Программа по определению имеет бо́льшую общность, иначе её можно было бы заменить таблицей с параметрами приёмочных тестов.

Т.к. задача останова является NP-полной, то, по-видимому, нельзя ожидать от тестов и ответа на вопрос достижимости (1) какого-либо результата. Тем не менее, обычно факт завершения программы для каких-то входных значений рассматривают как косвенный признак, позволяющий надеяться, что программа завершается всегда.

### Уровни абстракции

В сложных системах, с которыми имеет дело человек, выделяются уровни абстракции. Повышение уровня абстракции — абстрагирование, понижение — конкретизация. 

В программных системах переход между уровнями абстракции происходит в момент реализации. Функция может служить наглядным примером связи между абстрактным и конкретным. Имя функции используется как короткая запись некоторого вычисления на более высоком уровне абстракции. А тело функции — подробная реализация этого же вычисления на более низком уровне абстракции.

Аналогичное явление возникает при конструировании составных структур данных из структур меньшего размера. Или при объединении данных и методов в объект. Или при создании библиотек, содержащих наборы инструментов для решения классов задач.

Вне программных систем также можно обнаружить уровни абстракции. К примеру, передача сигнала. На некотором уровне абстракции сигнал может иметь семантическую нагрузку. На следующем уровне семантическая нагрузка преобразуется в слова. Далее, при произнесении слова превращаются в звук (который также имеет временну́ю структуру — высота тона, паузы, интонация, n-граммы...). Звук, в свою очередь может быть оцифрован (следующий уровень абстракции), закодирован и передан посредством радиосвязи в виде радиосигнала (низший уровень абстракции).

Понимание абстрагирования и конкретизации крайне важно для разработки любых сложных систем, а в особенности для разработки программных систем, как наиболее сложных на сегодняшний день из создаваемых человеком. К сожалению, процесс абстрагирования/конкретизации неоднозначен и во многом имеет характер инженерного искусства. Есть много эвристических правил и рекомендаций, как надо и как не надо выполнять абстрагирование.

Каким образом качество ПО связано с абстракциями? Абстракции напрямую влияют на следующие характеристики ПО и процесса разработки ПО:
- приемлемость для команды (либо слишком низкоуровневые абстракции, либо наоборот, слишком сложные);
- скорость onboarding'а (нестандартные абстракции ещё надо освоить);
- рекрутинг; (Широко распространённые абстракции освоены многими разработчиками, присутствующими на рынке. Новые абстракции могут прокладывать себе дорогу через фреймворки и библиотеки.)
- стоимость (скорость/сложность) внесения изменений;
- защита от ошибок или наоборот, поощрение ошибок;
- размер кодовой базы;
- производительность программы;
- реализуемость (может оказаться, что некоторые сложные вещи невозможно реализовать на низком уровне абстракций за разумное время);
- и т.п.

Важно отметить, что абстракции в первую очередь необходимы людям. Компьютеры, по-всей видимости, могут работать на самых низких уровнях абстракции после удаления компилятором всех высокоуровневых аспектов.

### "Прямолинейность" кода (цикломатическая сложность)

#### 1. Тестовые данные и "прямолинейность" кода

TODO: посмотреть рекомендации из основополагающей книги по юнит-тестам

Основным современным подходом является использование разнообразных тестов (юнит-тесты, приёмочные тесты, функциональные тесты, интеграционные тесты, ...). Предполагается, что если тестовые данные подготовлены на основе требований, в значительной степени покрывают требования и код не противоречит тестовым данным, то код в какой-то степени соответствует предъявляемым требованиям.

Что означают обычные рекомендации о том, что тестовые данные должны быть "достаточно разнообразными", чтобы обеспечивать покрытие? В частности, какой смысл в рекомендации того, что необходимо тестировать "граничные случаи"? Если функция в каком-то смысле "прямолинейная", то проверка граничных случаев позволяет "обоснованно предполагать", что функция ведёт себя в соответствии с требованиями и в диапазоне значений между граничными случаями.

Что означает "прямолинейность"? На мой взгляд, свойство "прямолинейности" можно сформулировать следующим образом:

> Функция **прямолинейна** в некотором диапазоне входных значений в том случае, если для каждого значения из диапазона выполняется один и тот же код.

Несмотря на очевидную слабость определения, оно позволяет нам отделить наиболее проблематичный вид кода — условное ветвление. Если какое-то значение приводит к выбору другой ветви, то такое значение нарушает "прямолинейность". Поэтому и требуется дополнительное тестирование.

Существует понятие ["цикломатической сложности"](https://ru.wikipedia.org/wiki/Цикломатическая_сложность) программы — количества разных путей в графе потока управления. При цикломатической сложности, равной 1, программа, по-видимому, будет прямолинейной. Если мы хотим протестировать все возможные пути, то нам потребуется как минимум столько же отдельных тестов/кейсов, сколько существует путей, т.е. минимальное число тестов, обеспечивающих выполнение всего кода, будет равно цикломатической сложности.

#### 2. Типы данных, уменьшающие цикломатическую сложность

Интуитивное представление о "прямолинейности" некоторых функций может получить серьёзное подкрепление, если мы воспользуемся обобщёнными типами (дженериками) и условимся использовать только "чистые" функции.

Классический пример. Как может быть реализована функция, имеющая тип `f: [A] => A => A`?

<spoiler title="реализация">
```scala
val f: [A] => A => A = [A] => (a: A) => a
```
Иными словами — `identity`.  
</spoiler>

Т.к. функция должна работать для произвольных типов, то в ней не может быть какой-то специальной обработки отдельных значений. И автоматически такая функция соответствует определению "прямолинейной" на всём диапазоне возможных входных значений.

#### 3. "Распрямление" if-boolean и match-enum

В некоторых программах ещё встречаются boolean-флаги, напрямую управляющие ходом программы:

```scala
def adjusment(value: Int, useHiLevel: Boolean): Int =
  val level = if useHiLevel then hi else low
  level - value
```
Каждый флаг, используемый таким образом, может увеличить цикломатическую сложность программы в 2 раза. Чтобы протестировать `adjusment` потребуется написать два набора тестовых данных — со значением флага `true` и `false`. Кроме того, все boolean-переменные совместимы между собой. Из-за этого легко ошибиться, передав не тот флаг.

Чтобы сделать несовместимые boolean-значения, применяются специализированные enum-типы:
```scala
sealed trait LevelConfig
object LevelConfig:
  case object Hi extends LevelConfig
  case object Low extends LevelConfig

def adjusment(value: Int, levelConfig: LevelConfig): Int =
  val level = levelConfig match
    case LevelConfig.Hi  => hi
    case LevelConfig.Low => low
  level - value
```

Как избавиться от `if`-а внутри программы?

В ООП существует [паттерн "Стратегия"](https://ru.wikipedia.org/wiki/Стратегия_(шаблон_проектирования)), а в функциональном программировании — просто функция в качестве параметра или by-name параметр:
```scala
def adjusment(value: Int, level: => Int): Int =
  level - value
```
Условный оператор из основной программы переносится на уровень конфигурирования. Тем самым тестирование основной программы становится проще.

#### 4. "Рельсовое программирование" и цикломатическая сложность

Во многих задачах алгоритм решения оказывается последовательным, но при этом каждое действие может завершиться неудачей. В таком случае может применяться идея ["железнодорожно-ориентированного" программирования](https://habr.com/ru/articles/339606/). На Scala похожий результат достигается при использовании `Option` или `Either`:

```scala
def foo(aOpt: Option[Int]): Option[Int] =
  aOpt.flatMap(a => b(a)).flatMap(b => c(b))

def bar(aEither: Either[String, Int]): Either[String, Int] =
  aEither.flatMap(a => b(a)).flatMap(b => c(b))
```

Непосредственный расчёт цикломатической сложности не внушает оптимизма, потому что ветвления по-сути остались на месте. Однако, т.к. переход от Happy path к обработке ошибок реализован в библиотеке, то при тестировании достаточно проверить корректность лишь Happy path, а библиотека представит гарантию корректной передачи ошибок.

Таким образом, использование линейного кода, построенного с помощью монад, будет иметь эффективную цикломатическую сложность, равную 1, т.е. код будет "прямолинейным".

#### 5. Циклы vs. map/flatMap

Следующим оператором после `if`, вносящим вклад в цикломатическую сложность, является оператор цикла (`for`, `while`, ...).
Естественным способом распрямления кода является использование `.map`, `.flatMap` на коллекциях. Получающийся код будет прямолинейным. А все детали реализации, возможно содержащие циклы, будут на уровне библиотеки.

Очевидно, что не все циклы возможно переписать таким образом. Остаётся только максимально изолировать оставшиеся циклы и тщательно протестировать все граничные случаи.

### Задание функции таблицей и алгоритмом

С математической точки зрения функция представляет собой отображение `A ⇒ B`. Одним из способов представления отображения является табличный — в строках таблицы указывается конечный набор пар входных и выходных значений `{(a,b)} ⊆ A⨯B`. При этом множество входных данных конечно и его мощность равна количеству примеров.

Другим способом является алгоритмический — описывается алгоритм/программа, позволяющая получить выходное значение из входного `f: A ⇒ B`. Мощность множества входных данных равна мощности типа `A`.

Табличное представление функции используется в юнит-тестах. Алгоритмическое — в коде. Требования к программному обеспечению могут быть выражены в форме алгоритма, сформулированного на высоком уровне абстракции. Например, "при нажатии на кнопку А данные формы Б сохраняются в базу данных". В коде тот же алгоритм может быть выражен на более низком уровне абстракции и более формально.

### Эквивалентность функций

Можно ли убедиться, что две отдельные функции эквивалентны (`f ≡ g`), то есть для всех входных значений возвращают одинаковые результаты (или производят одинаковые действия)?

Если обе функции заданы в табличной форме, то достаточно проверить конечное множество пар и убедиться, что они совпадают.

Если одна функция задана в табличной форме (тест), а другая в алгоритмической (код), то без дополнительных предположений нельзя сказать, что функции эквивалентны. Можно сделать более слабое заключение о том, что алгоритмическая функция не противоречит табличным значениям (`тест ⊆ код`), для чего подставить тестовые данные в алгоритм.

В типичном случае тестовые данные готовятся на основе функциональных требований (функции, заданной на высоком уровне абстракции) и вручную проверяется (либо предполагается), что табличные данные соответствуют требуемой функции (`тест ⊆ требования`). Затем эти табличные данные используются в юнит-тестах для проверки того, что тестовые данные также не противоречат реализованной функции (`тест ⊆ код`). Можно ли на основе этих двух свойств сделать вывод о том, что код соответствует требованиям (`код ≡ требования`)? В общем случае — нет.

Какие дополнительные предположения необходимо сделать, чтобы можно было с определённой степенью уверенности говорить о том, что *код соответствует требованиям*?

#### Доказательство эквивалентности

Доказать эквивалентность двух функций, рассматриваемых как чёрные ящики, в общем случае невозможно. Зачастую пространство аргументов имеет больше элементов, чем можно перебрать за разумное время. (В обратную сторону ситуация несколько лучше. Чтобы опровергнуть эквивалентность, достаточно привести единственный пример, на котором функции дадут разный результат. Отсюда, по-видимому, следует рекомендация TDD писать "красный" тест.)

Если же мы рассматриваем две функции вместе с их реализацией, то можно попытаться предъявить цепочку эквивалентных преобразований, переводящую из одной формы в другую.

Рассмотрим пример.

```scala
def f(a: Int): Int =
  CD(B(a))

def g(a: Int): Int =
  D(BC(a))
```
(здесь имена функций `BC` и `CD` соответствуют их реализациям)

Подстановка тела чистой функции (`CD` или `BC`) является эквивалентным преобразованием. Аналогично и абстрагирование чистой функции (извлечение выражения в отдельную функцию с добавлением нового имени) тоже является эквивалентным преобразованием.

Выполняя одно из этих эквивалентных преобразований, мы получим **промежуточную форму**:
```scala
def h(a: Int): Int =
  D(C(B(a)))
```

Тем самым, получается цепочка эквивалентных преобразований `f ≡ h ≡ g`. ∎

Если же такую цепочку эквивалентных преобразований построить не удалось, то мы, к сожалению, не сможем обоснованно утверждать, что функции эквивалентны. Все остальные наши попытки, надежды и заблуждения можно отложить в сторону, и принять важный факт: 

> *Обоснованно утверждать, что какие-либо функции эквивалентны, мы можем только предъявив математическое доказательство их эквивалентности*.

Для нас важно рассмотреть, каким образом мы могли бы доказать эквивалентность алгоритма, заданного в требованиях к ПО, и алгоритма, реализованного разработчиками.

Разработчики уже имеют замечательный инструмент, обеспечивающий точное доказательство эквивалентности — компилятор. Если программа собирается, значит имя функции эквивалентно её реализации. Это даёт возможность полностью автоматического доказательства эквивалентности между высокоуровневым описанием алгоритма и конкретной реализацией. Если требования к программе записаны формальным языком и существует цепочка эквивалентных преобразований в работающую программу, то мы автоматически получаем **программу, достигающую требуемого результата**.

В процессе доказательства эквивалентности мы можем использовать некоторые приёмы. TODO

#### Гарантии корректности "по построению"

В некоторых доказательствах в математике используется подход "по построению". Т.е. строится мысленная конструкция определённым образом с соблюдением заданных ограничений. Затем оказывается, что эта конструкция обладает требуемыми свойствами в силу того, что на каждом шаге соблюдались ограничения.

#### Доказательство сделанной работы с помощью типов. 1

Типы данных могут выступать/рассматриваться в качестве логических утверждений, а работающая программа, преобразующая один тип в другой, может служить конструктивным доказательством результирующего утверждения ([изоморфизм Карри — Ховарда](https://ru.wikipedia.org/wiki/Соответствие_Карри_—_Ховарда)).
```scala
def solve(t: Task): Solution =
  ???
```
Если функция `solve` является чистой тотальной функцией без побочных эффектов, то для каждой задачи `Task` она сможет алгоритмически предоставить решение `Solution`.

Вот как можно было бы отразить алгоритм решения квадратного уравнения: 
```scala
def `решение квадратного уравнения`(a: Double, b: Double, c: Double): () | Double | (Double, Double) =
  ???
```
Глядя на сигнатуру этой функции, мы можем заключить, что у произвольного квадратного уравнения может быть 0, 1 или 2 вещественных корня.

#### Доказательство сделанной работы с помощью типов. 2

Попробуем смоделировать ситуацию, при которой мы сможем гарантировать, что экземпляр сущности был вставлен в базу данных. (То есть реализовать обработчик HTTP-запроса `POST /form`.) Сформулируем требование к программе:
```
TODO: Сервис должен сохранить полученную форму или вернуть ошибку.
```
В такой формулировке действие "сохранить" не отражено в результате (является побочным эффектом). Для проверки корректности работы потребуются моки и другая магия.

Какой результат обеспечит уверенность в том, что форма сохранена? Например, идентификатор, сгенерированный базой данных. В таком случае, требование к программе будет выглядеть так:
```
TODO: Простой JSON RPC сервис должен, получив форму в виде JSON, вернуть идентификатор формы в базе данных или ошибку.
```
Уже само требование, сформулированное в такой форме, фокусирует наше внимание не на процессе ("сохранить"), а на предъявляемом результате этого процесса ("идентификатор формы в базе данных").

Воспользуемся opaque типами на уровне библиотеки доступа к БД. (Вопрос написания такой библиотеки мы оставим за скобками.)

Пусть библиотека предоставляет следующий интерфейс:
```scala
opaque type Идентификатор[E] = Int

/** Возвращает идентификатор вставленной строки, сгенерированный базой. */
def вставить[A](a: A): ОперацияБД[Идентификатор[A]] = ???

/** Возвращает сущность A по идентификатору.
 * Тип идентификатора - обычный, т.к. поступает извне.
 */
def найти[A](id: Int): ОперацияБД[Option[A]] = ???

/** Выполнить операцию и вернуть IO (результат или ошибку). */
def выполнитьВБазеIO[A](op: ОперацияБД[A])(using db: DB): IO[A] = ???

def значениеИлиОшибка[A](ao: A | ошибка): ОперацияБД[A] =
  ao match
    case о: ошибка => 
      ОперацияБД.ошибка(о)
    case a =>
      ОперацияБД.значение(a)
```
(Кстати сказать, функция `значениеИлиОшибка` является конструктивным доказательством простой теоремы — "любое значение или ошибка представимы в виде `ОперацияБД`".)
Далее мы исходим из того, что библиотека протестирована и работает корректно.

Также нам потребуется библиотека http4s для реализации HTTP-сервиса и такая вспомогательная функция:

```scala
def `простой JSON RPC сервис`[A, B](f: A => IO[B]): Request[IO] => IO[Response[IO]] = запрос =>
  for 
    форма         <- запрос.as[Форма]
    идентификатор <- `сохранить в базе`(форма)
    ответ         <- Ok(идентификатор.asJson)
  yield
    ответ
```
Естественно, для записи в базу, необходимо получить соединение:
```scala
val пулСоединений: IO[DB] = ???
```

Пусть наша форма уже представлена в виде case-class'а с поддержкой сериализации в JSON:
```scala
case class Форма(data: Int)

given formDecoder: Decoder[Форма] = deriveDecoder
given formEncoder: Encoder[Форма] = deriveEncoder
```

Запишем требование и попробуем его конкретизировать с использованием имеющихся инструментов.

```
TODO: Простой JSON RPC сервис должен, получив форму в виде JSON, вернуть идентификатор формы в базе данных или ошибку.
```

Часть `"Простой JSON RPC сервис должен, получив форму в виде JSON, вернуть"` соответствует и заменяется на вышеприведённую функцию `простой JSON RPC сервис`:
```scala
`простой JSON RPC сервис`(TODO: вернуть идентификатор формы в базе данных или ошибку)
```
Часть требования `"... или ошибку"` уже предусмотрена в типе `IO`.

Остаётся реализовать вставку формы в базу. Т.е. сконструировать задание для БД `вставить`, и выполнить это задание в базе:
```scala
выполнитьВБазеIO(вставить(форма))
```
Чтобы что-то можно было выполнить в базе, необходимо получить соединение из пула. Объединение двух последовательных действий `IO` в одно действие осуществляется либо через `flatMap`, либо через `for`:
```scala
def `сохранить в базе`[A](a: A): IO[Идентификатор[A]] =
  for 
    соединениеСБД <- пулСоединений
    идентификатор <- выполнитьВБазеIO(вставить(a))(using соединениеСБД)
  yield
    идентификатор
```

Для удобства добавим конкретную версию функции для нашего типа формы:
```scala
def `сохранить форму в базе и вернуть идентификатор формы в базе данных`(форма: Форма): IO[Идентификатор[Форма]] =
  `сохранить в базе`(форма)
```

Продолжая эквивалентные преобразования требований, получаем:
```scala
`простой JSON RPC сервис`(`сохранить форму в базе и вернуть идентификатор формы в базе данных`)
```

Остаётся только завернуть в "церемонию", предлагаемую библиотекой http4s:
```scala
val routes =
  HttpRoutes.of[IO] {
    case запрос @ POST -> Root / "form" =>
      `простой JSON RPC сервис`(`сохранить форму в базе и вернуть идентификатор формы в базе данных`)(запрос)
  }
```

Что можно заметить? Во-первых, требования к программе, сформулированные с акцентом на результат, приводят к программе, корректность которой отражена в типах. Во-вторых, программа распадается на несколько независимых функций, вопрос корректности которых может быть рассмотрен индивидуально. В-третьих, собственно корректность сохранения в базе данных "доказывается" путём предоставления конструктивного доказательства в виде программы, сводящей задачу сохранения к вызову библиотечных функций (доказательство корректности которых мы оставляем за скобками, и считаем априори корректными).

И самое главное, требования к программе эквивалентными и уточняющими преобразованиями преобразованы в действующую программу. Сам процесс преобразования/конкретизации может служить доказательством эквивалентности (при условии, что термины понимаются сторонами корректно и в процессе конкретизации выбрана правильная реализация терминов).

Нужны ли для этой программы тесты?

#### Увеличение сложности программ

Отдельные требования, выражаемые в разных частях документации, либо разными заинтересованными сторонами, могут взаимодействовать между собой и приводить в конечном итоге к усложнению программы.

Рассмотрим, например, взаимодействие таких требований:
- простой JSON RPC сервис должен, получив форму в виде JSON, вернуть идентификатор формы в базе данных или ошибку
- все изменения в БД должны производиться транзакционно;
- все изменения в БД должны логироваться с указанием имени пользователя и момента выполнения изменений.

Реализация первого требования выглядит относительно несложно и рассмотрена выше.

Чтобы поддержать второе требование на уровне типов, мы можем исключить доступ к БД без явного указания транзакции. Например, можно объявить функцию верхнего уровня `простой транзакционный JSON RPC сервис`, которая будет управлять транзакциями. Все сервисы окажутся транзакционными.

Реализация третьего требования зависит от выбранного способа аутентификации на уровне базы. Если для каждого пользователя приложения создаётся пользователь базы, то возможна реализация на уровне самой базы с помощью триггера. Если же используется только аутентификация на уровне сервиса, то потребуется передавать идентификатор пользователя из запроса на уровень базы данных. В этом случае, логирование можно произвести с помощью следующей функции:

```scala
case class СтрокаЖурнала(типФормы: ИдентификаторТипаФормы, userId: UserId, time: LocalDateTime)

def logUserId[A: ТипФормы](dbid: Идентификатор[A], userId: UserId, момент: IO[LocalDateTime] = now()): ОперацияБД[Идентификатор[СтрокаЖурнала]] = 
  for
    time <- ОперацияБД.lift(момент)
    строкаЖурнала = СтрокаЖурнала(типФормы, userId, time)
    идентификатор <- вставить(строкаЖурнала)
  yield
    идентификатор
```

Для использования этой функции потребуется изменить операцию сохранения:
```scala
def `сохранить форму в базе, залогировать операцию и вернуть идентификаторы`(форма: Форма)(using UserId): IO[(Идентификатор[Форма], Идентификатор[СтрокаЖурнала])] =
  for 
    бд <- пулСоединений
    given DB = бд
    идентификатор <- выполнитьВБазеIO(вставить(форма))
    идентификаторСтрокиЖурнала <- выполнитьВБазеIO(logUserId(идентификатор, summon[UserId]))
  yield
    (идентификатор, идентификаторСтрокиЖурнала)
```

### Классификация ошибок

В программах встречаются самые разные ошибки. Можно попытаться указать некоторые классы ошибок и оценить, насколько тесты и/или типы позволяют обнаруживать/предотвращать такие ошибки.

1. Ошибки, обнаруживаемые компилятором

   Есть несколько классов ошибок, которые мучают разработчиков на интерпретируемых языках с динамической типизацией:
   - опечатки;
   - вызов несуществующих функций;
   - неправильный набор аргументов функций;
   - несовместимые типы данных в одном выражении (причём некоторые языки в рантайме это проглатывают и втихаря выдают какой-то неожиданный результат);
   - использование неинициализированных переменных (при включенной опции `-Ysafe-init`);
   - ...


   Эти ошибки обнаруживаются в ходе выполнения именно той самой строчки кода, где они содержатся. По-видимому, это является причиной, по которой разработчики на таких языках пытаются обеспечить высокий процент покрытия строк кода — чтобы компенсировать отсутствие компилятора.

   Компилятор является мощным инструментом доказательства теорем о корректности программного обеспечения. Желательно по максимуму переносить все потенциальные проблемы на этап компиляции. Тем самым будут предотвращены многие ошибки времени исполнения и отпадёт необходимость писать избыточное количество тестов.

2. Ошибка на миллиард долларов (NPE)

   Похоже, что эта ошибка существует уже более полувека: [Null References: The Billion Dollar Mistake, Tony Hoare](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/). Суть проблемы заключается в том, что ссылочный тип данных помимо нормального значения, обладающего ожидаемым поведением, может иметь специальное значение `null`, обладающее неожиданным поведением. И многие языки скромно умалчивают (aka подразумевают по *умолчанию*) о том, что в любом месте программы в переменной типа `MyCuteObject` может прятаться какая-то неожиданность.

   По-видимому, обычные юнит-тесты не в силах предсказать NPE (`NullPointerException`). Если имеющиеся тесты проходят, то они и в дальнейшем будут проходить. Возможно, [мутационное тестирование](https://habr.com/ru/articles/334394/) или [property-based тестирование](https://habr.com/ru/companies/typeable/articles/570922/) как-то поможет.

   В Scala 3 (с включённой опцией `-Yexplicit-nulls`), как и в Kotlin, реализован подход, в котором `Null` представлен явным образом. В Java применяются аннотации `@NotNull` и статический анализ кода.
   Использование `Option` или явных `Null` типов, наряду с отказом от использования `null` в проекте, позволяет надеяться на то, что ошибка NPE окажется практически исключена.

3. Выход за пределы диапазона допустимых значений.

   Например, номер порта больше 65К. Или номер порта меньше 1024 для обычного пользователя. Или отрицательное значение там, где допускаются только неотрицательные. Или строковое значение, используемое в качестве модели `enum`, не входящее в список известных значений.

   [Refined-типы](https://habr.com/ru/articles/574080/) позволяют сформировать ограничения на значения примитивных типов и тем самым отделить валидацию от использования проверенных типов. Вместо строковых значений, очевидно, следует использовать собственно `enum`, специально придуманного для закрытого перечня взаимоисключающих вариантов.

   При попытке решить эту проблему с помощью тестов обычно рекомендуется на каждую границу диапазона написать два теста — положительный и отрицательный. Причём для одного параметра, возможно, придётся протестировать множество функций, которые с этим параметром работают. Объём работы, по-видимому, больше, чем при использовании refined-типов.

4. Попадание данных, не прошедших валидацию, в бизнес-логику.
   
   Здесь на помощь приходят [алгебраические типы данных](https://ru.wikipedia.org/wiki/Алгебраический_тип_данных) (тоже ADT, но не надо путать с абстрактными типами данных). Их особенность заключается в том, что они хорошо дружат с математикой и доказательством корректности программ.

   При успешной валидации мы должны сформировать тип, представляющий только корректные данные и исключающий возможность представления некорректных данных.

   Рассмотрим пример.

   В языке Go алгебраические типы данных не поддерживаются. Для сообщения об ошибках имеется "джентельменское соглашение" — возвращается пара `(A, error)` и значение проверяется тогда, когда `error` равен `nil`. К сожалению, такое соглашение соблюдается не всегда. Иногда на вызывающей стороне разработчик может проигнорировать ошибку. А иногда автор библиотеки может вернуть сразу и ошибку и значение. (Например, в стандартной библиотеке работы с файлами возвращается псевдо-ошибка EOF и, одновременно, прочитанные данные.)

   В языке Scala для похожей задачи можно воспользоваться типом `Either[error, A]`. Этот тип представляет алгебраическую сумму. Значением такого типа будет строго либо левая, либо правая часть. Тем самым исключаются невозможные комбинации — "и левая и правая часть", "нет ни левой, ни правой части".

5. Выход за границы массива в цикле.

   Если при обработке коллекций пользоваться высокоуровневым инструментарием наподобие `map`, `filter`, `fold`, ..., то необходимость пользоваться циклами практически отпадает. Тем самым исключается класс ошибок выхода за границы массива.

6. Ошибки неправильного понимания требований.

   Если разработчик понял требования неправильно, то и тесты и типы будут соответствовать пониманию разработчика. По-видимому, такие ошибки предотвратить трудно.

7. Примеры нарушения требований.

   Если нам известны примеры, то по ним легко можно написать тест, который будет это нарушение воспроизводить.

   Для исправления такого обнаруженного нарушения желательно понять, нельзя ли нарушенное требование представить на уровне типов данных. Если это возможно, то тем самым будут исключены все возможные нарушения требования в будущем.

8. Ошибки некорректного состояния.

9. Ошибки, вызванные дублированием параметров.

   Два компонента, связанных через TCP порт, должны быть сконфигурированы с одинаковым значением номера порта. Иначе они не смогут связаться друг с другом.

10. Например, несовместимость версий.


   TODO:   https://www.thinksys.com/qa-testing/types-software-testing-bugs/ 

    Incorrect calculations.
    Boundary-related errors.
    Syntax errors. 
    Performance errors. 
    Compatibility errors. 
    Input validation errors. 
    Memory errors.
    Runtime errors. 
    Logic errors.

### Системный подход

TODO: подвести к тестированию с использованием моков. Проблема моков.

Как только мы начинаем говорить о тестировании, возникает вопрос, где провести границу того, что мы будем тестировать. Чем отличается *юнит-тестирование* от *интеграционного*? Как отделить зависимости?

На мой взгляд, подходящим мыслительным инструментом является *системный подход*. Разрабатываемая программа, работающая в каком-то окружении, является системой (*runtime-системой*), состоящей из взаимосвязанных компонентов. Каждый компонент в свою очередь представляется подсистемой, состоящей из компонентов следующего уровня.

Деление программы на системы/компоненты неоднозначно и зависит от точки зрения. Например, ту же программу, при взгляде на исходный код, можно разделить на библиотеки, пакеты, отдельные файлы. Связи между такими компонентами будут представлены через явный или неявный import. В некоторых случаях один и тот же программный код может использоваться и при запуске большой системы в качестве подсистемы, и в качестве системы верхнего уровня. Например, подсистема импорта данных вполне может работать и автономно.

Несмотря на то, что юнит-тесты зачастую организуются вокруг файлов с программным кодом, их задачей является тестирование компонента будущей runtime-системы. Runtime-система обычно представляет собой программный код + конфигурация (т.е. программа, запущенная в определённой конфигурации). Поэтому одной из задач, стоящих перед юнит-тестами, является инициализация используемых компонентов таким образом, чтобы заставить программный код работать похожим образом, как в действующей системе, в тех же режимах. 

*Интеграционным тестом*, насколько я могу судить, называют тест системы бо́льшего размера, чем помещается в одном файле. В сущности, интеграционным тестом можно было бы называть юнит-тест, тестирующий достаточно большую подсистему (большой "юнит"). Для целей тестирования конфигурация такой подсистемы (SUT — system under test) может отличаться от конфигурации рабочей системы. Более того, может быть собрана новая тестовая система с совершенно другой конфигурацией, включающей как компоненты будущей рабочей системы, так и другие компоненты, не используемые в рабочей системе. Например, какие-то компоненты могут быть заменены на их упрощённые версии (заглушки, тестовые реализации интерфейсов, моки, менее производительные сервисы), часть компонентов отключена, а оставшиеся сконфигурированы для работы в этих новых условиях. 

Ценность создаваемой тестовой системы заключается в том, что хотя бы часть компонентов работает в режимах, похожих на рабочие. Разработка же самой тестовой системы и всех вспомогательных компонентов, их поддержка, может быть отнесена к накладным расходам. По-видимому, желательно добиваться целей тестирования минимальными усилиями.

TODO: закончить про системный подход

### Пример цепочки действий

Пусть "простая продажа" подразумевает выполнение следующих действий:
- чистое вычисление (например, полной стоимости заказа с учётом скидок, уведомления пользователя, содержащего сгенерированный номер заказа);
- транзакция в БД;
- отправка SMS.

Традиционно для тестирования такой составной операции, задействующей внешние зависимости (БД и сервис СМС), используются мок-объекты, позволяющие подменить зависимости и протестировать именно этот сценарий.

На этом примере хочется понять, каким образом можно написать качественную программу и при этом обойтись без моков.

Во-первых, представим результат побочных эффектов с помощью типов данных. Сервис SMS может предоставлять подтверждение отправки с помощью экземпляра trait'а:
```scala
sealed trait ПодтверждениеОтправкиSMS:
  val кому: String
  val текст: String
```
Наличие ключевого слова `sealed` гарантирует, что экземпляр может быть создан только в модуле, отвечающем за отправку SMS.

```scala
case class КвитанцияОбработкиЗаказа(
  идентификатор: Идентификатор[Заказ], 
  подтверждениеОтправкиSMS: ПодтверждениеОтправкиSMS,
)
```

Несмотря на то, что экземпляр этого класса нам не обязательно нужен в дальнейшем, само его существование говорит о том, что существует идентификатор, сгенерированный базой данных и существует `ПодтверждениеОтправкиSMS`, которое может быть создано только сервисом SMS.

Собственно реализация сервиса простой продажи будет иметь следующий вид:
```scala
def `простая продажа`(заказ: Заказ)(using SmsService, DB): IO[КвитанцияОбработкиЗаказа] = 
  for
    id <- выполнитьВБазеIO(вставить(заказ))
    уведомление = `текст уведомления`(заказ, id)
    sms <- уведомить("пользователь", уведомление)
  yield
    КвитанцияОбработкиЗаказа(id, sms)
```
Мы исходим из того, что корректность самих сервисов и используемых функций лежит за рамками настоящего рассмотрения. Остаётся вопрос корректности реализации сервиса.

Сервис имеет две внешние зависимости — `SmsService` и `DB`. Обычной практикой является реализация мок-объектов и запуск сервиса в рамках теста. В данном случае, на мой взгляд, корректность реализации демонстрируется сигнатурой функции. Само наличие функции, возвращающей `КвитанцияОбработкиЗаказа`, является конструктивным доказательством того, что такая квитанция будет сформирована в результате исполнения этого алгоритма. А содержимое квитанции демонстрирует результат — объект записан в БД и уведомление отправлено.

### Взаимодействие с подсистемами, обладающими состоянием (statful)

Для распределённых систем широкое признание получила идея отказа от "сессии" при взаимодействии между удалёнными системами и использовании stateless-протоколов (без состояния) наподобие REST. Аналогичная идея зачастую может быть использована при организации взаимодействия между подсистемами. Вместо цепочки действий, приводящих подсистему в требуемое состояние, формируется сложный объект, передаваемый подсистеме. Подсистема, обрабатывая этот сложный объект, самостоятельно приходит в конечное состояние.

К примеру, при работе с базой данных может потребоваться произвести согласованные изменения в нескольких таблицах, например: сохранить изменённые свойства объекта в новую строку таблицы версий, записать вложенные элементы в связанную таблицу, сохранить сведения о пользователе, выполняющем операцию, залогировать момент времени. Вместо того, чтобы эти изменения выполнять на уровне приложения, можно сформировать высокоуровневое событие, содержащее все требуемые параметры ("пользователь А изменил объект Б в момент времени Т"), и передать это событие в хранимую процедуру на уровне базы. Хранимая процедура, в свою очередь, выполнит все необходимые изменения в рамках транзакции.

Тестирование приложения, использующего такую подсистему, значительно упрощается. Мок-объект, представляющий подсистему, становится обычной табличной функцией, возвращающей предопределённый результат в ответ на сложное событие.

#### Пример разделения сценария

Пусть в рамках сценария нам требуется выполнить несколько действий в базе и в других сервисах:

1. Сохранить новую версию заказа (бд).
2. Записать в журнал сведения о пользователе (бд).
3. Записать заявку на списание/возмещение средств (бд).
4. Отправить sms-уведомление пользователю (сервис SMS).

Прямолинейная реализация сценария может выглядеть так:
```scala
def `изменение заказа`(заказ: Заказ, пользователь: String, момент: LocalDateTime)(using SmsService, DB): IO[Unit] =
  for
    id <- выполнитьВБазеIO(upsert(заказ))
    userId <- выполнитьВБазеIO(найтиПользователя(пользователь))
    _ <- выполнитьВБазеIO(logUserId(id, userId, IO{момент}))
    уведомление = `текст уведомления`(заказ, id)
    sms <- уведомить(пользователь, уведомление)
  yield
    ()
```

Эта реализация трижды обращается к базе данных для выполнения отдельных шагов алгоритма. При тестировании потребуется реализовать мок-объект, обрабатывающий три обращения и возвращающий содержательные ответы, достаточные для продолжения работа сценария. Причём, т.к. сам сценарий кроме базы данных использует и другие зависимости, то для его тестирования потребуется смоделировать и все остальные сервисы (в данном случае — SMS).

Если часть алгоритма, относящуюся к БД, выделить в отдельную функцию, то получим такой код:
```scala
case class Изменение[A](сущность: A, пользователь: String, момент: LocalDateTime)

def `изменение заказа2`(заказ: Заказ, пользователь: String, момент: LocalDateTime)(using SmsService, DB): IO[Unit] =
  val событиеИзмененияЗаказа = Изменение[Заказ](заказ, пользователь, момент)
  for
    квитанция <- выполнитьВБазеIO(обработатьСобытиеИзменения(событиеИзмененияЗаказа))
    уведомление = `текст уведомления`(заказ, квитанция.идентификатор)
    sms <- уведомить(пользователь, уведомление)
  yield
    ()
```
Такую функцию будет проще протестировать, так как база данных используется однократно, а сложная логика, определяемая схемой базы, изолирована. Вместо повторения части алгоритма при создании мок-объекта, достаточно указать одно возвращаемое значение в ответ на единственный вызов функции.

Закономерный вопрос, что происходит с логикой, исключённой из прикладного сценария. Как и раньше, логика может быть реализована в приложении, например, таким образом:
```scala
case class КвитанцияОбИзменении[A](идентификатор: Идентификатор[A], userId: UserId, строкаЖурнала: Идентификатор[СтрокаЖурнала])

def обработатьСобытиеИзменения[A: ТипФормы](изменение: Изменение[A]): ОперацияБД[КвитанцияОбИзменении[A]] =
  for 
    id <- upsert(изменение.сущность)
    userId <- найтиПользователя(изменение.пользователь)
    строкаЖурнала <- logUserId(id, userId, IO{изменение.момент})
  yield
    КвитанцияОбИзменении(id, userId, строкаЖурнала)
```
Либо эта логика может быть перенесена на уровень базы данных в виде хранимой процедуры без изменения сценария.

Вышеприведённая реализация явным образом отражает атомарность операции — все шаги, требуемые логикой приложения и схемой базы данных, объединены в одно действие.

Такая реализация обладает следующими преимуществами:
1. За счёт дженериков и наличия квитанции (то есть подтверждения результата в типе функции), корректность кода можно считать доказанной системой типов и код можно исключить из тестирования.
2. Поскольку код работает исключительно с базой данных, то он может быть протестирован в рамках интеграционного тестирования с тестовой базой без использования реального/поддельного sms-сервиса.
3. Даже если реализовывать мок-объект в классическом виде, здесь это сделать немного проще, т.к. требуется моделировать только БД, хотя по-прежнему потребуется реализовать несколько ответов мок-объекта.

### Применимость юнит-тестов

Видя необоснованные надежды, возлагаемые на юнит-тесты, хотелось бы понять, что в действительности можно ожидать от тестов.

#### Воспроизведение известных багов

Если обнаружена какая-то ошибка в программе, то для целей исправления удобно иметь возможность многократного запуска программы и воспроизведения этой ошибки. Если удаётся реализовать юнит-тест и локализовать ошибку в каком-то одном модуле, то исправить ошибку будет значительно проще.

Нужен ли тест после исправления ошибки? Иногда ошибка может "возвращаться". В частности, если над проектом работают несколько человек, то другой разработчик, не знающий причин внесения изменений, может изменить код так, что та же ошибка проявится снова. Также код, где уже была обнаружена ошибка, с бо́льшей вероятностью содержит и другие ошибки. Адаптировать имеющийся тест для воспроизведения новой ошибки может быть легче, чем писать тест с нуля.

Если ошибка была связана с несовместимостью с новой версией библиотеки, то сохранение теста позволит преотвратить случайное обновление.

#### Одиночный тест "прямолинейного" кода

Если код, работоспособностью которого мы интересуемся, является "прямолинейным", то для его проверки достаточно выполнить однократный запуск. Исходя из свойств "прямолинейности", код должен работать и для других значений.

В частности, если у нас имеется код с дженериками, то он, обычно, является прямолинейным относительно типа. А значит, для проверки работоспособности такого кода может быть достаточно одного теста при каком-то значении типа.

#### Smoke-тест ("Дымовой" тест)

Такой тест нужен для запуска и проверки в простейшем случае. Позволяет убедиться, что программа вообще хоть в каких-то условиях хоть как-то работает.

#### Набор тестов-индикаторов на каждое требование

Разновидностью Smoke-тестов можно считать набор тестов-индикаторов по одному на каждую "фичу". Каждый такой тест проверяет наличие определённой функциональности и падает в случае её отсутствия. Такой набор позволяет не пытаться объять необъятное и доказать соответствие требованиям, а решить вполне достижимую задачу — что для каждого задокументированного[^2] требования предусмотрен/существует код и при некоторых входных данных требование выполняется. В случае, если разработчик случайно произведёт изменение, отключающее ранее реализованную функциональность, соответствующий тест-индикатор позволит это оперативно обнаружить. Имеет смысл в названии таких тестов прямо указывать их индикаторную роль (`featureMSP3142`, `fixMSP4231`, `indicatorUserAuthFeature`, ...).

[^2]: в качестве документации может использоваться номер issue или ссылка на дизайн.



1. Юнит-тесты должны помогать обнаруживать ошибки на более ранних этапах жизненного цикла (до запуска в эксплуатацию).
2. Набор юнит-тестов должен помогать обеспечивать защиту ранее реализованных функций при рефакторинге. (Если функция полностью прекратит работу, то какой-то тест упадёт.)
3. Написание юнит-тестов должно поощрять разработчиков делать код более модульным, тем самым косвенно улучшая его качество.
4. Сами юнит-тесты должны служить документацией к API и помогать понять на рабочих примерах, как им пользоваться.

#### Чего не надо ожидать от юнит-тестирования

1. "Если все юнит-тесты выполняются, то программа в целом соответствует требованиям."
2. "Если покрытие строк кода выше 95%, значит, ..."
  - "...вероятность серьёзной проблемы в программе не выше 5%."
  - "...при реализации следующей функции вероятность возникновения серьёзной проблемы в программе не выше 5%."
  - "...внесение небольшого изменения не приведёт к катастрофическим последствиям с вероятностью 95%."
  - "...требования выполняются на 95%."
  - "...(любое утверждение о требованиях)."
3. "Если покрытие строк кода ниже 50%, значит, ..."
  - "...в программе много багов, особенно в строчках, не покрытых тестами."
  - "...программа вряд ли соответствует требованиям."

С учётом принципиальной ограниченности табличных функций, такие ожидания не имеют под собой оснований.

#### Ограниченная польза юнит-тестов

1. Защита от появления ранее исправленных ошибок ("регрессионное тестирование").
2. Помощь при разработке — удобный запуск разрабатываемого модуля. В последующем, при доработке модуля, те же тесты легче доработать и использовать для запуска изменённого модуля, чем писать заново. Такие тесты можно пометить, прямо указав в их названии `run`, `debug` ...
3. Улучшение программного интерфейса для программиста — сигнатур функций, структуры классов и т.д. За счёт того, что разработчик думает не только о реализации, но и о том, как пользоваться разрабатываемым модулем.
4. Поддержка документации по использованию API в актуальном состоянии (так как все примеры часто перекомпилируются и выполняются). Здесь, по-видимому, не стоит злоупотреблять желанием всё "задокументировать" в виде тестов. Если имеется десяток однотипных модулей, то, на мой взгляд, нет необходимости документировать каждый одинаково подробно. Достаточно задокументировать один, а для остальных указать отличия.
5. Исключение глобальных переменных, т.к. с ними тестировать неудобно. Разработчик помучается и, может быть, избавится от них.
6. Помощь разработчику в поисках причин падения тестов. Если какой-то тест упал, то разработчик вынужден заниматься troubleshooting'ом. Чтобы этот процесс упростить и ускорить, тесты и код желательно писать так, чтобы при падении сообщалась информация, необходимая для локализации и устранения проблемы.

По-видимому, юнит-тесты в первую очередь полезны самим разработчикам, а также несколько улучшают процесс разработки в целом.

Пользу юнит-тестов следует соотносить с затратами на их разработку, поддержку, модификацию кода для удобства тестирования. Если разработка юнит-тестов требует больших усилий, то, возможно, овчинка выделки не стоит. Сами по себе тесты серебряной пулей не являются и не обеспечивают высокого качества ПО автоматически. А затраты на их разработку, поддержку, рефакторинг — вполне себе заметны.

# Заключение

В этой части рассмотрены некоторые соображения, которые позволяют подойти к тестам с рациональных позиций. Если во главу угла поставлено качество программного обеспечения, то тесты являются лишь одним из компонентов процесса разработки. Значительно большее влияние на качество могут оказать типы данных.

Под качеством ПО понимается оптимизация целевой функции при соблюдении ограничений (соответствие требованиям). Причём в качестве целевой функции может выступать и стоимость разработки. А так как на разработку и поддержку тестов уходят усилия, то небезынтересен вопрос о том, каким образом обеспечить качество ПО при минимальном количестве тестов. Например, за счёт использования типов данных, исключающих некоторые классы ошибок.
