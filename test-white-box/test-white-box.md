Классическое модульное тестирование (unit-тестирование) предполагает возможность осуществления рефакторинга и разбиения большой программы на маленькие блоки, удобные для тестов. Можно изначально разрабатывать программу, удовлетворяющую тестам (TDD - test driven development).

Одной из разновидностей модульного тестирования можно считать propery-based testing, основанное на нахождении универсальных свойств, которые должны быть справедливы для любых входных данных, и на генерации случайных входных данных. Такой подход особенно хорошо работает для программ, основанных на математических законах.

Иногда оказывается, что необходимо протестировать сложную программу, не имея возможности разобрать её на части. В таком случае тестируемая программа представляет собой ~~черный~~ белый ящик (белый - потому что мы имеем возможность изучать внутреннее устройство программы). 

Под катом описаны несколько подходов к тестированию с разной степенью сложности (вовлеченности) и разной степенью покрытия.

<cut />

**Мы предполагаем, что тестируемую программу можно представить в виде чистой функции без внутреннего состояния. (В случае, если есть внутреннее состояние, то должна быть возможность сброса этого состояния к фиксированному значению.)*

### Тестовый стенд (test bench)

Прежде всего, так как тестируется всего одна функция, код вызова которой всегда одинаков, то у нас нет необходимости создавать отдельные unit test'ы. Достаточно в цикле передавать исходные данные (`input`) и проверять результаты (`expectedOutput`). Чтобы в случае обнаружения ошибки можно было идентифицировать проблемный набор тестовых данных, все тестовые данные надо снабдить меткой (`label`). Таким образом, один набор тестовых данных можно представить в виде тройки:

```scala
case class TestCase[A, B](label: String, input: A, expectedOutput: B)
```

Результат одного прогона можно представить в виде `TestCaseResult`:
```scala
case class TestCaseResult[A, B](testCase: TestCase[A, B], actualOutput: Try[B])
```
(Результат запуска мы представляем с помощью `Try`, чтобы захватить возможные исключения.)

Чтобы упростить прогон всех тестовых данных через тестируемую программу, можно использовать вспомогательную функцию, которая будет вызывать программу для каждого входного значения:

```scala
def runTestCases[A, B](cases: Seq[TestCase[A, B])(f: A => B): Seq[TestCaseResult[A, B]] = 
  cases
    .map{ testCase => 
      TestCaseResult(testCase, 
        Try{ f(testCase.input) }
      ) 
    }
    .filter(r => r.actualOutput != Success(r.testCase.expectedOutput))
```

Эта вспомогательная функция вернёт проблемные данные и результаты, которые отличаются от ожидаемых.

Для удобства можно отформатировать результаты тестирования
```scala
def report(results: Seq[TestCaseResult[_, _]]): String = 
  s"Failed ${results.length}:\n" + 
    results
      .map(r => r.testCase.label + ": expected " + r.testCase.expectedOutput + ", but got " + r.actualOutput)
      .mkString("\n")
```

и выводить отчёт только в случае ошибок:
```scala
val testCases = Seq(
  TestCase("1", 0, 0)
)

test("all test cases"){
  val testBench = runTestCases(testCases) _
  val results = testBench(f)
  assert(results.isEmpty, report(results))
}
```

### Подготовка входных данных

В простейшем случае можно вручную создать тестовые данные для проверки программы, записать их напрямую в тестовом коде, и использовать, как продемонстрировано выше. Часто оказывается, что интересные случаи тестовых данных имеют много общего и могут быть представлены как некоторый базовый экземпляр, с небольшими изменениями.

```scala
val baseline = MyObject(...)
val testCases = Seq(
  TestCase("baseline", baseline, ???),
  TestCase("baseline + (field1 = 123)", baseline.copy(field1 = "123"), ???)
)
```

При вложенных структурах данных большим подспорьем являются линзы, например, из библиотеки [Monocle](http://julien-truffaut.github.io/Monocle/):

```scala
val testObject1 = (field1 composeLens field2).set("123")(baseline)
// val testObject1 = baseline.copy(field1 = baseline.field1.copy(field2 = "123"))
```

### Использование DSL для представления изменений

Если мы формируем тестовые данные путём внесения изменений в некоторый исходный объект, то важную часть описания теста составляет перечень внесённых изменений. Вообще говоря, всё описание теста сводится к указанию начального объекта и перечня изменений. Чтобы перечень изменений не расходился с фактическими изменениями, необходимо следовать принципу "единой версии правды" - источник уникальной информации должен быть в одном экземпляре, в остальные точки информация должны распространяться автоматически, с необходимыми преобразованиями. (Если этот принцип нарушать, то неизбежно расхождение двух версий изменений - реальной и описанной.)

В нашем случае первичным источником информации являются сами изменения, и нам хотелось бы вывести из них текст, содержащий перечень изменений. Навскидку можно предложить использовать макрос, который будет захватывать исходный код изменений, и использовать исходный код в качестве документации. Это, по-видимому, хороший и относительно несложный способ задокументировать фактические изменения. К сожалению, мы теряем возможность оформить перечень изменений удобным для конечного пользователя способом.

Вторым способом, который позволяет манипулировать перечнем изменений, является создание встроенного специализированного языка (DSL), описывающего изменения. Такой язык должен быть достаточно выразительным, чтобы описывать все интересующие нас изменения. Результатом разбора языка изменений будет модель, содержащая перечень изменений. Потребуется также интерпретатор, который сможет применить изменения, описываемые моделью, к переданному объекту.

<spoiler title="Подробности языка изменений">
Язык изменений представляет собой довольно сложную конструкцию, включающую несколько компонентов, которые также, в свою очередь, нетривиальны.
1. Модель структуры данных. 
2. Модель изменений.
3. Собственно Embedded(?) DSL - вспомогательные конструкции, extension-методы, для удобного конструирования изменений.

Приведём пример
```scala
val target: Entity[Target]
val updateField1 = target \ field1 := "123"
val updateField1 = Set(PropertyAccess(target, Property(field1, typeTag[String])), LiftedString("123"))
```
То есть с помощью extension-методов `\` и `:=` формируется объекты `PropertyAccess`, `Set` из ранее созданных объектов `target` и `field1`. Также за счёт (опасных) implicit-конвертаций строка "123" упаковывается в `LiftedString`.

В качестве модели данных может быть использована типизированная онтология (см. https://habr.com/post/229035/ и https://habr.com/post/222553/).

Для представления изменений необходим набор классов наподобие `Set`:
- `Modify` - применение функции
- `Changes` - применение нескольких изменений последовательно
- `ForEach` - применение изменений к коллекции элементов
- и т.д.
</spoiler>
