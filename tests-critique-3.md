
# Бестолковые тесты versus качественное ПО. Часть 3. Что получится?

В [первой части](/part1) мы рассмотрели несколько примеров тестов, которые выглядели несколько несуразно. Попробуем разобрать, что получится, если применить соображения, изложенные во [второй части](/part2).

- [Бестолковые тесты versus качественное ПО. Часть 3. Что получится?](#бестолковые-тесты-versus-качественное-по-часть-3-что-получится)
    - [Тавтологичные тесты \*](#тавтологичные-тесты-)
    - [Тесты ради покрытия](#тесты-ради-покрытия)
    - [Поверхностное тестирование](#поверхностное-тестирование)
    - [Тесты + флаги](#тесты--флаги)
    - [Моки 1. "Алгоритм шиворот-навыворот"](#моки-1-алгоритм-шиворот-навыворот)
    - [Моки 2. Тесты ради тестов](#моки-2-тесты-ради-тестов)
    - [Тесты - бухгалтеры](#тесты---бухгалтеры)
    - [Глубокое тестирование](#глубокое-тестирование)
    - [Раздутые тесты](#раздутые-тесты)
- [Заключение](#заключение)


### Тавтологичные тесты *

Напомним пример:

```scala
def config(): Config = 
  Config("a", 2)

def testConfig(): Unit =
  val cfg = config()
  assert(cfg.a == "a")
  assert(cfg.b == 2)
```

"Как бы функция" `config` на самом деле не содержит алгоритма. И даже не является таблицей. Это просто константа. По-видимому, мы имеем дело с вырожденным случаем.

Как мог появиться такой код? Возможно, есть некая библиотека, для которой формируется конфигурация. И режим работы этой библиотеки описывается этой конфигурацией. И используется в нескольких модулях, чтобы обеспечить согласованность конфигураций.

Собственно значения в конфигурации выводятся в ходе реализации напрямую из требований. При изменении требований разработчик внесёт изменения в код, обнаружит упавший тест, и будет вынужден также исправить этот тест. То есть наличие такого теста снижает скорость внесения изменений (адаптации).

Мощность множества входных значений равна 1 (`Unit`).

Исходя из того, что этот тест не несёт какой-либо смысловой нагрузки и при этом снижает скорость адаптации, его следует удалить.

### Тесты ради покрытия

Тесты, вызывающие код, но игнорирующие результат:
```scala
def f(x: Int): Int = x + 1

def test(): Unit =
  f(0)
```

Если такой тест один, то его можно рассматривать как smoke-тест и это вполне допустимый способ запуска программы в ходе разработки. В таком тесте может подготавливаться набор входных данных, которые удобны для отладки. 

Больше одного теста такого типа, по-видимому, бесполезны. Такие тесты можно рассматривать в той же категории, что и недостижимый код. С экономической точки зрения - пустая трата усилий (waste).

Возможно, стоит пометить такие тесты аннотацией `@Ignore`, чтобы исключить регулярный запуск, либо удалить.

### Поверхностное тестирование

Пример теста, в котором хотя и тестируется возвращаемое значение, но лишь формально:

```scala
def test(): Unit =
  val request = ???
  val response = http.Get(request)
  assert(response.status == 200)
```
Такой тест никак не помогает разработчику в понимании и устранении проблемы. Если он упадёт, разработчику потребуется написать дополнительные тесты, позволяющие увидеть, что же именно возвращается.

Было бы удобнее, если бы в этом тесте при падении выдавалась вся контекстная информация.
```scala
def test(): Unit =
  // ...
  assert(response.status == 200, s"response = $response")
```
Ещё лучше было бы уйти от поверхностного тестирования и перейти к тестированию собственно модуля сервиса, исключив http-обвязку. При этом мы бы имели доступ к типизированному возвращаемому значению и могли бы выдать более осмысленное сообщение об ошибке.

### Тесты + флаги

Пример кода с флагами:
```scala
def foo(a: Boolean, b: Boolean, c: Boolean) =
  val resA = if a then
    doa()
  else
    dona()
  
  val resB = if b then
    dob()
  else
    donb()

  val resC =  if c then
    doc()
  else
    donc()
  
  resA + resB + resC
```
Здесь функция, по-видимому, имеет две проблемы:
- нарушает "принцип единственной ответственности" (SRP);
- неоправданно увеличивает цикломатическую сложность кода за счёт использования флагов.

Было бы неплохо такую функцию разбить на части, которые мы могли бы протестировать независимо - `testDoa`, `testDona`, ..., `testDonc`. Отдельно можно протестировать операцию агрегирования - `testSum`, если необходимо.

Что можно сделать с флагами?

Самый прямолинейный и универсальный способ - заменить флаги на enum'ы, содержащие 2 варианта. Такая замена позволяет решить некоторые проблемы простых флагов:
- явный и обособленный тип значения, несовместимый с другими флагами (благодаря чему исключается использование вместо другого флага);
- явные имена значений, описывающие смысл каждого значения.

Если от флага зависит какая-то одна часть программы, то можно сконфигурировать функцию там, где значение флага становится известным, и далее передавать уже эту функцию.

Также некоторые идеи предложены в [Флаги в аргументах функций](https://habr.com/ru/articles/349602/) (перевод [Toggles in functions](https://akrzemi1.wordpress.com/2017/02/16/toggles-in-functions/)).

В итоге можно получить такую программу:
```scala
sealed trait ConfigA
object ConfigA:
  case object FirstVariantForA extends ConfigA
  case object SecondVariantForA extends ConfigA

sealed trait ConfigB
...
sealed trait ConfigC
...

def algA(configA: ConfigA): () => Int = 
  configA match
    case FirstVariantForA  => doa
    case SecondVariantForA => dona
    
def algB(configB: ConfigB): () => Int = ???
def algC(configC: ConfigC): () => Int = ???

def foo(a: => Int, b: => Int, c: => Int) =
  a + b + c
```

### Моки 1. "Алгоритм шиворот-навыворот"

Пример кода с использованием моков, в котором алгоритм повторяется в виде теста:

```scala
trait IFoo:
  def inc(): Unit
  def get: Int

def alg(f: IFoo): Int =
  f.inc()
  f.inc()
  f.get

def testAlg(): Unit =
  val mock = Magic[IFoo]()
  Magic.expectSequence{
    mock.inc()
    mock.inc()
  }.when{
    mock.get
  }.returnResult(2)
  assert(alg(mock) == 2)
  mock.check()
```
По-сути здесь алгоритм дублируется немного в другом виде. Вместо проверки ожидаемых результатов мы вынуждены фиксировать то, каким образом этот результат достигается. Тем самым затрудняется внесение изменений в будущем.

Можно ли этого избежать?

По-видимому, основной причиной использования mock'ов при тестировании кода с зависимостями является наличие внутреннего состояния внешнего сервиса, который мы моделируем. Моки позволяют воспроизвести состояние путём 

TODO: дополнить теоретическую часть соображениями по поводу состояния.

Возможно, стоит отделить процесс приближения к состоянию от снапшота состояния.

TODO: убрать нападки на моки?

### Моки 2. Тесты ради тестов

Пример теста без тестируемого кода:
```scala
def foo(db: IDatabase): Int =
  db.ReadSomeValue()

def test(): Unit =
  val mock = Magic[IDatabase]()
  Magic.when{
    mock.ReadSomeValue()
  }.returnResult(10)
  assert(foo(mock) == 10)
```
Здесь мы наблюдаем тест, который живёт своей жизнью и для которого нет кода, который будет потом работать в production. С экономической точки зрения, это бесполезная трата ресурсов. Возможно, этот код можно было бы выделить в отдельный проект и рассматривать этот проект как учебный.

Иногда бывает ситуации не настолько очевидные. Например, кода немного всё-таки есть, но он относительно простой и прямолинейный, а моделируемая зависимость существенно сложнее. В этом случае надо рационально соотносить усилия по моделированию с пользой для проекта. Вполне может оказаться, что овчинка выделки не стоит.

Ещё один способ избавиться от моков - интеграционное тестирование. Вместо попытки моделирования сложной системы будет использована сама эта система.

TODO: 


### Тесты - бухгалтеры

Пример теста, проверяющего случайные факты:
```scala
def routes(): List[Route] = ???

def test(): Unit =
  assert(routes().length == 10)
```

Здесь количество путей не является частью требований и вероятно будет изменяться в будущем по мере роста проекта. Наличие такого теста лишь несколько замедлит добавление функций. Таким образом, этот тест следует удалить.

### Глубокое тестирование

Тест, в котором создаётся специальный код 
```scala
def insertA(db: IDB, a: A): Unit =
  db.Insert(a)

def test(): Unit =
  val realDb = openTempDb()
  case class B()
  realDb.CreateTable[B]()
  realDb.Insert(B())
  val b = realDb.Read[B]()
  assert(b == B())
```
TODO:

### Раздутые тесты

Тесты и код, которые делают слишком много.
```scala
def doAandB(a: IA, b: IB) = ???

def testDoAandB(): Unit =
  val mockA
  val mockB
  doAandB(mockA, mockB)
  mockA.check()
  mockB.check()
```
С точки зрения SRP функция должна делать что-то одно на том уровне абстракции, на котором её имя имеет смысл. Собственно реализация функции может состоять из нескольких частей. Но эти составные части должны принадлежать нижнему уровню абстракции. В данном случае функция имеет корректное имя `A and B`, которое сразу даёт понять, что функция делает два действия, имеющих смысл на этом уровне абстракции. У нас есть два варианта - понять, как объединены эти действия и перейти на следующий уровень абстракции - `doC`. Либо разделить эту функцию на две независимых.

Для модульного тестирования, конечно в любом случае следует тестировать отдельно A и B. Тестирование C можно рассмотреть в случае, если соединение A и B нетривиально.

# Заключение

В основе тестирования лежит идея проверки соответствия кода и требований. К сожалению, доказать это соответствие с помощью табличных тестов не представляется возможным.

Вместе с тем, тесты могут оказывать положительный эффект на процесс разработки за счёт 
- улучшения модульности программы,
- переключения фокуса разработчика на удобство использования разрабатываемого модуля,
- поддержки документации в постоянно актуальном состоянии,
- и т.п.


TODO:

  //     if b then
      if c then
        abc()
      else
        abnc()
    else
      if c then
        anbc()
      else
        anbnc()
  else
    if b then
      if c then
        nabc()
      else
        nabnc()
    else
      if c then
        nanbc()
      else
        nanbnc()


TODO: 
    // Основной целью тестирования, на мой взгляд, является проверка того, что программа соответствует требованиям. Другие цели, такие как документирование, обмен знаниями и т.п., играют второстепенную роль. Если тест падает, это должно означать, что какому-то требованию код больше не соответствует. Падение теста должно содержать достаточно информации для понимания контекста и облегчать поиск и устранение ошибки. Например, тестирование endpoint'а зачастую не позволяет понять, что именно пошло не так, т.к. client-side ошибка, возвращаемая HTTP, не содержит подробностей. В то же время, тестирование обработчика может дать больше информации о том, что именно пошло не так.


    // В настоящей заметке приведены несколько примеров тестов, которые не настолько полезны, как могли бы быть. Проблема заключается в принципиальной ограниченности табличных функций, которыми, по-сути, являются тесты. Из-за этой принципиальной ограниченности надежды на то, что написание бо́льшего количества тестов как-то улучшит качество программы, тщетны.
