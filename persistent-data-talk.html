<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Неизменяемые структуры данных</title>

    <link rel="stylesheet" href="reveal-js/css/reveal.css">
    <link rel="stylesheet" href="reveal-js/css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="reveal-js/lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal-js/css/print/pdf.css' : 'reveal-js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h3>Неизменяемые структуры данных</h3>
            <h5>(persistent data structures)</h5>
            <p>
                <small><a href="http://primetalk.ru/">Арсений Жижелев, Праймтолк</a> / <a
                        href="mailto:zhizhelev@primetalk.ru">zhizhelev@primetalk.ru</a></small>
            </p>
            <aside class="notes">
                <p>Добрый день. Меня зовут Арсений Жижелев и я хотел бы представить вашему вниманию некоторые
                    соображения о неизменяемых структурах данных и их полезных свойствах.</p>

            </aside>

        </section>

        <!--
1. Введение. 
2. Математические выкладки в тетрадке и на маленькой школьной доске. Постепенное построение рисунков. Конструирование из отдельных деталей (без переделки).
3. Конструирование новых данных - 1) раскладывание по контексту имён; 2) промежуточные вычисления; 3) сборка результата
4. Производительность. Выделение памяти, сборка мусора.
5. Красивые структуры данных 
	a. список
	b. Rope
	c. Красно-черные деревья (Scala)
6. Структуры данных, представляющие вычисления.
	a. lazy, by ref, 
	b. Task, 
	c. Stream
7. Persistent data structures
8. Взаимодействие между потоками; взаимодействие с реальным миром.

Отношение: 
- вся суть функционального программирования вытекает из неизменности данных. "Закон сохранения данных"
- практическое удобство неизменных данных заключается в отсутствии проблем при наличии многих потоков. По-видимому, поэтому функциональное программирование получило такое развитие.

Однако, можно получить те же практические преимущества и потокобезопасность и в других парадигмах программирования, включая ООП. Необходимо лишь полностью исключить модифицируемые данные. (На самом деле, теоретически можно и оставить модифицируемые данные, но только в некотором локальном пространстве, доступ к которому имеет только один поток. Однако, из-за отсутствия чёткой границы в коде между одним потоком и другим, оказывается, что программы, содержащие переменные, в целом не являются потокобезопасными.)

        -->
<!--
final class Vector[+A](
  private[collection] val startIndex: Int,
  private[collection] val endIndex: Int, focus: Int)
extends ... with VectorPointer[A @uncheckedVariance]
private[immutable] trait VectorPointer[T] {
    private[immutable] var depth: Int = 0
    private[immutable] var display0: Array[AnyRef] = null
    ...
    private[immutable] var display5: Array[AnyRef] = null
-->
        <section style="text-align: left">
            <h3>План</h3>
            <ul>
                <li>Введение</li>
                <li class="fragment">Аналогии из реального мира</li>
                <li class="fragment">Конструирование новых данных</li>
                <!--<li class="fragment">производительность, сборка мусора</li>-->
                <li class="fragment">Некоторые красивые структуры данных
                    <!--<ul>-->
                        <!--<li>Односвязный список</li>-->
                        <!--<li>Rope</li>-->
                        <!--<li>Красно-черные деревья</li>-->
                    <!--</ul>-->
                </li>
                <li class="fragment">Структуры данных, представляющие вычисления
                    <!--<ul>-->
                        <!--<li>lazy, by ref</li>-->
                        <!--<li>Task (fs2), IO (cats)</li>-->
                        <!--<li>Stream</li>-->
                    <!--</ul>-->
                </li>
                <!--<li class="fragment">персистентные структуры данных-->
                    <!--<ul>-->
                        <!--<li>1</li>-->
                    <!--</ul>-->
                <!--</li>-->
                <!--<li class="fragment">Взаимодействие с реальным миром</li>-->
                <li class="fragment">Корректное программирование</li>
            </ul>
            <aside class="notes">
                <p>
                    На слайде представлен примерный план доклада
                </p>
                <p>
                    [NF] будут рассмотрены аналогии из физического мира, которые нас окружают
                </p>
                <p>
                    [NF] показан порядок, как из имеющихся данных конструируются новые структуры данных
                </p>
                <!--<p>-->
                    <!--[NF] применение автоматических систем управления памяти (сборщиков мусора), делает работу-->
                    <!--с такими данными весьма удобной.-->
                <!--</p>-->
                <p>
                    [NF] рассмотрены некоторые простые структуры данных
                </p>
                <p>
                    [NF] а также структуры данных, представляющие "замороженные" вычисления
                </p>
                <p>
                    [NF] использование неизменяемых структур данных для создания корректных программ
                </p>
                <!--<p>-->
                    <!--[NF] некоторые более интересные структуры данных-->
                <!--</p>-->
                <!--<p>-->
                    <!--[NF] а также взаимодействие с реальным миром-->
                <!--</p>-->
            </aside>
        </section>
        <section style="text-align: left">
            <b>Введение</b>
            <ul>
                <li>Времена изменились</li>
                <li class="fragment">высокоуровневые программы</li>
                <li class="fragment">многоядерность (с 2005 г.)</li>
                <li class="fragment">неизменяемые данные оказались <b>удобнее</b>
                </li>
            </ul>
            <aside class="notes">
                <p>Некоторое время тому назад объёмы памяти не были столь значительны. Программистам приходилось явно
                    переиспользовать ячейки памяти для новых значений. Постепенно программисты привыкли и даже когда
                    объёмы памяти стали значительными, по-прежнему широко использовались переменные.
                </p>
                <p>Кроме того, программы сейчас становятся весьма высокоуровневыми. Поэтому накладные расходы на
                    обслуживание неизменяемых данных оказываются незначительными в сравнении с операциями верхнего
                    уровня. На более низком уровне по-прежнему активно используются переменные.
                </p>
                <p>[NF] В 2005 году "закончился бесплатный обед" (<a
                        href="http://www.gotw.ca/publications/concurrency-ddj.htm">The Free Lunch Is Over A Fundamental
                    Turn Toward Concurrency in Software By Herb Sutter</a>.) Повышение производительности теперь
                    достигается только за счёт распараллеливания.</p>
                <p>[NF] "Удобство" неизменяемых данных - в первую очередь для программиста.
                    Во-первых, понять работу программы, в которой ничего не меняется, гораздо проще, чем работу
                    программы, в которой всё зависит от эфемерного текущего состояния программы.
                    Во-вторых, появляется возможность вести корректные рассуждения о работе многопоточных программ.
                    В-третьих, неизменяемые данные автоматически потокобезопасны.
                </p>
                <p>[NF] </p>
            </aside>
        </section>
        <section style="text-align: left">
            <b>Аналогии</b>
            <!--
            Математические выкладки в тетрадке и на маленькой школьной доске. Постепенное построение рисунков. Конструирование из отдельных деталей (без переделки).
            -->
            <ul>
                <li>Математические выкладки <img src="persistent-data-structures/maths_writing.jpg" style="float: right;" align="right"/>
                </li>
                <li class="fragment">Построение рисунков добавлением элементов</li>
                <li class="fragment">Сборка модели из деталей конструктора</li>
            </ul>
            <aside class="notes">
                <p>
                    Математические выкладки в тетрадке. Мы записываем исходное выражение, потом несколько раз
                    переписываем его, заменяя отдельные части результатами вычислений. Иногда мы наносим дополнительные
                    пометки прямо на последнее выписанное выражение: сокращаем множители; взаимно уничтожаем слагаемые с
                    разными знаками; надписываем промежуточные результаты действий. Когда мы впоследствии переписываем
                    выражение "начисто", мы пользуемся сделанными пометками и интерпретируем их по ходу записи.
                </p>
                <p>
                    Теперь посмотрим, что происходит, если мы будем математические выкладки делать на школьной доске.
                    Если выражение достаточно развесистое, то его может быть проблематично переписывать целиком, так как
                    предыдущий шаг нам пришлось бы вначале стереть. В то же время, мы достаточно легко можем стирать
                    части выражения и заменять их результатами промежуточных вычислений.
                </p>
                <p>
                    Если мы рисуем чертеж, то мы в основном постепенно добавляем детали и стараемся, чтобы не
                    приходилось ничего стирать (что, впрочем, не всегда получается).
                </p>
                <p>
                    Сборка из конструктора вообще подразумевает, что сами детали остаются неизменными, а мы лишь меняем
                    их положение в пространстве.
                </p>
            </aside>
        </section>
        <section style="text-align: left">
            <b>Конструирование новых данных</b>
            <ol>
                <li>Раскладывание по контексту имен (связывание имён)</li>
                <li class="fragment">Промежуточные вычисления</li>
                <li class="fragment">Сборка результата</li>
            </ol>
            <aside class="notes">
                <p>Вначале мы извлекаем части данных и, обычно, даём им имена в нашем локальном контексте. В
                    функциональном программировании такая операция может выполняться с помощью "сопоставления с
                    образцом" или pattern matching'а</p>
                <p>[NF] Затем мы выполняем необходимые промежуточные вычисления и сохраняем результаты также в локальном
                    контексте (связываем значения с именами); Что интересно, промежуточные вычисления вполне могут
                    включать локальные изменяемые переменные. Это никак не помешает этим вычислениям оставаться
                    "чистыми". Важное ограничение - отсутствие глобальных переменных и отсутствие доступа к внешнему
                    миру.</p>
                <p>[NF] После завершения операции мы собираем результирующую структуру данных</p>
            </aside>
        </section>
        <section style="text-align: left">
            <b>Конструирование новых данных (пример 1, filter)</b>
            <pre><code class="haskell" data-trim>
filter :: (a -> Bool) -> [a] -> [a]
filter _ []                 = []
filter p (x:xs) | p x       = x : filter p xs
                | otherwise = filter p xs
            </code></pre>
            <pre><code class="scala" data-trim>
def filter[A](p: A => Boolean)(list: List[A]): List[A] =
  list match {
    case Nil                => Nil
    case x :: xs if p(x)    => x :: filter(p)(xs)
    case _ :: xs            => filter(p)(xs)
  }
            </code></pre>
            <div class="fragment">
            <pre><code class="scala" data-trim>
def filter[A](p: A => Boolean)(list: List[A]): List[A] =
  list match {
    ... 
    case x :: xs => 
      val flag =  p(x)
      val filteredTail = filter(p)(xs)
      val result = if(flag) x :: filtered else filtered
      result
    ...
  }
          </code></pre>
            </div>
            <aside class="notes">
                <p>Посмотрим, как выглядит реализация простой функции filter.</p>
                <p>Во-первых, мы рассматриваем три шаблона на аргументы, с которыми имеем дело. В трёх разных случаях мы
                    имеем разные контексты именования.</p>
                <p>[NF] Посмотрим на наиболее полный второй случай более внимательно. Мы разбираем исходную структуру на два компонента и даём
                    имена этим компонентам - x и xs.</p>
                <p>Затем выполняем промежуточное вычисление p(x). Результат вычисления связывается с именем flag. </p>
                <p>Следующее имя - filteredTail - будет именовать результат промежуточного вычисления filter для хвоста списка.
                    Далее мы выполняем промежуточное вычисление условного выражения, которое конструирует нам результирующую структуру данных.
                    </p>
            </aside>
        </section>
        <section style="text-align: left">
            <b>Конструирование новых данных (пример 2 разбиение на строки)</b>
            <pre><code class="haskell" data-trim>
lines        :: String -> [String]
lines ""     =  []
lines s      =  let (l, s') = break (== '\n') s
                  in  l : case s' of
                            []      -> []
                            (_:s'') -> lines s''
            </code></pre>
            <pre><code class="scala" data-trim>
def lines(s: String): List[String] =
  s match {
    case ""  => Nil
    case _   => 
      val (l, s1) = break(_ == '\n')(s)
      val tail = s1 match {
                            case ""      => Nil
                            case _ :: s2 => lines(s2)
                          }
      l :: tail
  }
            </code></pre>
            <aside class="notes">
                <p>Взглянем с аналогичной стороны на реализацию функции lines (которая производит разбиение по переводам
                    строк).</p>
                <p>Исходная структура данных (список символов) в данном случае не требует разбора в локальном контексте.
                    Мы осуществляем промежуточные вычисления (break) и уже
                    результаты break разбираем на составляющие в локальном контексте и даём им имена. Далее мы всё-таки
                    разбираем s' на компоненты. Первый символ, перевода строки, мы игнорируем, а оставшуюся часть строки
                    обрабатываем рекурсивно.</p>
                <p>Последним действием мы собираем структуру данных.</p>
            </aside>
        </section>
        <section style="text-align: left">
            <b>Модификация неизмяемых структур</b>
            <img src="persistent-data-structures/Path-copying.png"/>
            <aside class="notes">
                <p>На рисунке можно видеть типичный механизм, используемый для модификации структур данных.
                    Называется Path copying.</p>
                <p>При внесении любых изменений в глубине структуры (в данном случае, добавление узла), мы вместо старых
                    узлов создаём новые и распространяем изменения вверх до корня. В результате получаем новый корень
                    и новые узлы, параллельные старым. Старый корень может по-прежнему использоваться для
                    доступа к предыдущей версии структуры.
                </p>
            </aside>
        </section>

        <section>
            <b>Красивые структуры данных (список)</b>
            <pre><code class="haskell" data-trim>
data List a = Nil | Cons a List a
            </code></pre>
            <pre class="fragment"><code class="haskell" data-trim>
data [a]    = []  | a : [a]
            </code></pre>
            <pre class="fragment"><code class="scala" data-trim>
sealed trait List[+T]
case object Nil extends List[Nothing]
final case class Cons[+T](head: T, tail: List[T])
  extends List[T]
            </code></pre>
            <div class="fragment">
            <pre><code class="scala" data-trim>
sealed abstract class List[+A] extends AbstractSeq[A] with ..
case object Nil extends List[Nothing]
final case class ::[B](
  private var hd: B, 
  private[scala] var tl: List[B]) extends List[B]
            </code></pre>
            </div>
            <aside class="notes">
                <p>Односвязный список представляет собой либо пустой список, либо пару - голова/хвост. </p>
                <p> [NF] В Хаскеле предусмотрен встроенный синтаксис для списков.</p>
                <p>На Scala - аналогичная структура, только немного более громоздко.</p>
                <p>По производительности - очень неплохая структура данных для типовых вариантов использования в
                    качестве неизменяемой структуры данных.</p>
                <p>Посмотрим, что там под капотом...</p>
                <p>[NF] О, ужас! Здесь же переменные!</p>
                <p>Как же так оказалось, что в immutable структуре содержатся var? Это как раз следствие низкоуровневой
                    оптимизации. hd модифицируется в методе десериализации,
                    а tl модифицируется в ListBuffer'е при добавлении элементов в конец списка. Тем самым достигается
                    разумная производительность - O(1) при добавлении элементов. И O(1) при конвертации в список
                    (типичный способ использования списков - конструирование через CanBuildFrom и последующая
                    конвертация в список).
                    При конвертации в List используется copy-on-write механизм. То есть после конвертации выставляется
                    флаг. И если мы попытаемся добавить следующий элемент, то весь буфер будет автоматически
                    скопирован.</p>
                <p>После конструирования (`toList`) структура становится неизменяемой.
                </p>
            </aside>
        </section>
        <section>
            <b>Красивые структуры данных (Rope/веревка)</b>
            <img src="persistent-data-structures/Rope_string_concat.png"/>
            <p>Производительность</p>
            <ul>
                <li class="fragment">Index O(log n)</li>
                <li class="fragment">Concat O(log n) (в худшем случае - O(n))</li>
                <li class="fragment">Split O(log n)</li>
                <li class="fragment">Insert O(log n) (в худшем случае - O(n))</li>
                <li class="fragment">Delete O(log n)</li>
            </ul>
            <aside class="notes">
                <p>Интересной структурой является Rope для хранения длинных строк.
                    Это immutable структура данных, которая обеспечивает весьма неплохие показатели для всех основных
                    операций со строками.</p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
            </aside>
        </section>
        <section>
            <b>Красивые структуры данных (Rope 2)</b>
            <section>
                <img src="persistent-data-structures/Rope_split_before.png"/>
            </section>
            <section>
                <img src="persistent-data-structures/Rope_split_after.png"/>
            </section>
            <section>
                <img src="persistent-data-structures/Rope_split_after2.png"/>
            </section>
            <aside class="notes">
                <p>На рисунках представлены преобразования структуры данных при выполнении операции split.</p>
                <p>Можно видеть, что начиная снизу создаются дополнительные узлы, и формируются две новые ветви и два
                    новых корня.</p>
                <p></p>
                <p></p>
                <p></p>
            </aside>
        </section>
        <section>
            <b>Красно-чёрные деревья</b>
            <ul>
                <li>Обычные деревья бинарного поиска</li>
                <li class="fragment">К узлам добавлен цвет - красный/чёрный</li>
                <li class="fragment">И поддерживаются инварианты:
                    <ul>
                        <li>красные узлы не могут ссылаться на красные узлы</li>
                        <li>количество чёрных узлов от вершины до пустых узлов одинаково для всего дерева</li>
                    </ul>
                </li>
                <li class="fragment">В результате: дерево полностью сбалансировано</li>
            </ul>
            <aside class="notes">
                <p>Красно-чёрные деревья это обычные деревья бинарного поиска, которые
                    при любых операциях поддерживают два инварианта, связанных с цветами узлов. За
                    счет этого обеспечивается оптимальная производительность дерева</p>
            </aside>
        </section>
        <section>
            <b>Красно-чёрные деревья (модель)</b>
            <pre><code class="haskell" data-trim>
data Color    = R | B
data Tree elt = E | T Color (Tree elt) elt (Tree elt)
            </code></pre>
            <div class="fragment">
            <pre><code class="scala" data-trim>
sealed trait Color
case object Red extends Color
case object Black extends Color

sealed trait Tree[+A]
case object E extends Tree[Nothing]
case class T[A](
  color: Color,
  left: Tree[A],
  x: A, 
  right: Tree[A]
) extends Tree[A]
            </code></pre>
            </div>
            <aside class="notes">
                <p>Цвет - либо R красный, либо B черный.</p>
                <p>А дерево - либо пустой узел, либо узел, содержащий цвет, левое/правое поддерево и элемент.</p>
                <p>То же самое на Scala (немного более многословно)</p>
                <p></p>
                <p></p>
            </aside>
        </section>
        <section>
            <b>Красно-чёрные деревья (балансировка)</b>
            <section>
                <img src="persistent-data-structures/Rbt_balance.png" style="height: 140mm"/>
                <aside class="notes">
                    <p>На рисунке представлены различные случаи нарушения инвариантов и способы исправления
                        нарушения. На всех деревьях x, y, z - рассматриваемые и исправляемые узлы, а a,b,c,d
                        нижележащие уже сбалансированные деревья.</p>

                    <p>Рисунок из статьи Криса Окасаки про красно-черные деревья (J. Functional Programming 9(4)
                        471–477, July 1999.
                        Cambridge University Press, 471 Red-Black Trees in a Functional Setting CHRIS OKASAKI)</p>
                    <p>Например, если x - вверху. До узлов a, b, c, d - один черный узел. Но y и z - красные.
                        После переписывания дерева оказывается, что остается один красный узел, но при этом до каждого из
                        поддеревьев все равно остаётся по одному чёрному узлу. И этот участок дерева стал сбалансированным.</p>
                    <p>Также можно смотреть на эти способы исправления инвариантов как на повороты/развороты дерева.</p>
                    <p></p>
                </aside>
            </section>
            <section>
            <pre><code class="scala" data-trim>
  def balance[A: Ordering](n: T[A]): Tree[A] = n match {
    case T(Black, T(Red, T(Red, a, x, b), y, c), z, d) => ???
    case T(Black, T(Red, a, x, T(Red, b, y, c)), z, d) => ???
    case T(Black, a, x, T(Red, T(Red, b, y, c), z, d)) => ???
    case T(Black, a, x, T(Red, b, y, T(Red, c, z, d))) => ???
    case t                                             => t
  }
            </code></pre>
                <aside class="notes">
                    <p>В качестве шаблонов используются модели, представленные на предыдущем рисунке. Например,
                        последняя строчка соответствует случаю, когда x - черный, а y левее z.</p>
                    <p>Все эти шаблоны связывают одни и те же имена с разными узлами с таким расчетом,
                    чтобы конечный результат был представлен одним выражением.</p>
                </aside>
            </section>
            <section>
            <pre><code class="scala" data-trim>
  def balance[A: Ordering](n: T[A]): Tree[A] = n match {
    case ... => T(Red, T(Black, a, x, b), y, T(Black, c, z, d))
    case ... => T(Red, T(Black, a, x, b), y, T(Black, c, z, d))
    case ... => T(Red, T(Black, a, x, b), y, T(Black, c, z, d))
    case ... => T(Red, T(Black, a, x, b), y, T(Black, c, z, d))
    case t   => t
  }
            </code></pre>
            <aside class="notes">
                <p>Видно, что результирующая часть дерева имеет идентичную структуру во всех случаях исправления.</p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
            </aside>
            </section>
        </section>
        <section>
            <p><b>Вычисления как данные</b></p>
            <ul>
                <li>lazy val</li>
                <li class="fragment">by ref</li>
                <li class="fragment">Task (fs2) (~ IO)</li>
                <li class="fragment">Stream (fs2)</li>
            </ul>
            <aside class="notes">
                <p>Среди структур данных особое место занимают структуры, включающие отложенные вычисления. Эти
                    структуры являются неизменными в том смысле, что либо результат вычисления запоминается и больше не
                    изменяется, либо в точности те же вычисления могут быть выполнены повторно.</p>
                <p>[NF] lazy val - простейший случай. Вычисление не выполняется, пока не потребуется результат. А
                    результат запоминается.</p>
                <p>[NF] by ref - просто сохраняем ссылку на функцию и вызваем, когда требуется. Очень даже подходящий
                    способ для чистых функций без побочных эффектов. </p>
                <p>[NF] Task - by ref на стероидах. Инкапсулирует отложенное вычисление и позволяет подклеивать
                    последующие шаги вычислений. Главным образом, позволяет сериализовать (упорядочить) шаги, обладающие
                    побочными эффектами, так как обычные вычисления могут быть легко переупорядочены. Гораздо лучше
                    Future с точки зрения предсказуемости результатов и эффективности использования ресурсов.</p>
                <p>[NF] Stream - конечный автомат (трансдьюсер), содержащий вычисления, позволяющие перерабатывать
                    дискретный поток данных на входе в дискретный поток данных на выходе. </p>
                <p>Представление вычислений в форме данных позволяет строить гибкие программы, существенно
                    отличающиеся от классического структурного программирования. Можно реализовать рекурсивные
                    алгоритмы, не ограниченные глубиной стека. Stream позволяет конструировать программы, обрабатывающие
                    big data при сохранении константного потребления памяти.
                </p>
            </aside>
        </section>

        <section style="text-align: left">
            <b>Stream (fs2) пример</b>
            <pre><code class="scala" data-trim>
def fahrenheitToCelsius(f: Double): Double =
  (f - 32.0) * (5.0/9.0)
def converter[F[_]](implicit F: Sync[F]): F[Unit] =
  io.file.readAll[F](Paths.get("fahrenheit.txt"), 4096)
    .through(text.utf8Decode)
    .through(text.lines)
    .filter(s => !s.trim.isEmpty && !s.startsWith("//"))
    .map(line => fahrenheitToCelsius(line.toDouble).toString)
    .intersperse("\n")
    .through(text.utf8Encode)
    .through(io.file.writeAll(Paths.get("celsius.txt")))
    .run

val u: Unit = converter[IO].unsafeRunSync()
            </code></pre>
        </section>

        <section style="text-align: left">
            <b>Корректное программирование</b>
            <ul>
                <li>Программа делает, что от неё ожидают:
                <ul>
                    <li class="fragment">Не зависает, не "падает" с исключениями</li>
                    <li class="fragment">Результаты правильные </li>
                    <li class="fragment">Производительность соответствует ожиданиям</li>
                </ul>
                </li>
                <li class="fragment">Как убедиться, что программа отвечает нашим ожиданиям?</li>
            </ul>
            <aside class="notes">
                <p>Обычно трудно точно сказать, что значит корректная программа. Зачастую все заинтересованные лица
                    очень по-разному представляют, что должна делать программа. Здесь мы будем говорить о корректности с
                    точки зрения программиста. То есть, программист, анализируя программу может в значительной степени
                    корректно понять как она работает, и это понимание должно быть очень близко к тому, что происходит на
                    самом деле.</p>
                <p>[NF] В частности, программа должна завершаться без ошибок.</p>
                <p>[NF] Результаты программы должны проходить имеющиеся тесты</p>
                <p>[NF] Программа должна потреблять разумное количество ресурсов (процессорного времени, памяти,
                    сетевого трафика, места на диске)</p>
            </aside>
        </section>
        <section style="text-align: left">
            <b>Корректное программирование (пример 1 merge sort JavaScript)</b>
            <pre><code class="javascript" data-trim>
function merge(left, right, arr) {
  var a = 0;
 
  while (left.length && right.length) {
    arr[a++] = (right[0] < left[0]) ? right.shift() 
                                    : left.shift();
  }
  while (left.length) {
    arr[a++] = left.shift();
  }
  while (right.length) {
    arr[a++] = right.shift();
  }
}
            </code></pre>
            <pre class="fragment"><code class="javascript" data-trim>
function mergeSort(arr) {
  var len = arr.length;
 
  if (len === 1) { return; }
 
  var mid = Math.floor(len / 2),
      left = arr.slice(0, mid),
      right = arr.slice(mid);
 
  mergeSort(left);
  mergeSort(right);
  merge(left, right, arr);
}
 
var arr = [1, 5, 2, 7, 3, 9, 4, 6, 8];
mergeSort(arr); // arr will now: 1, 2, 3, 4, 5, 6, 7, 8, 9
            </code></pre>
            <aside class="notes">
                <p>Рассмотрим в качестве примера кусочек алгоритма mergeSort (Кусочек, потому что весь алгоритм на
                    слайд не помещается).
                Реализация взята на сайте Розетта . ком. JavaScript - оказался несколько компактнее Java.</p>
                <p>Задача функции заключается в том, чтобы слить две предварительно отсортированные коллекции
                в одну. </p>
                <p>Первое, на что хочется обратить внимание, это то, что здесь имеется 4 переменные
                и все они в ходе исполнения программы меняются. Состояние - эфемерное. </p>
                <p>Затем, меняются аргументы функции. Причем если один из аргументов является возвращаемым
                    значением, то два других страдают безвинно. Тем самым, функция обладает неожиданным для пользователя
                    побочным эффектом.</p>
                <p>Далее. Из трех циклов всегда отрабатывают только два. К такому выводу можно прийти
                    только в результате внимательного моделирования того, как будут меняться переменные в ходе работы
                    программы. Перед последним циклом можно догадаться, что left уже пуст, но состояние right неизвестно.</p>
                <p>Коллекции должны иметь быструю реализацию length даже в условиях постоянных изменений.
                    По-видимому, длина коллекции должна храниться.
                    А выходная коллекция обязательно должна поддерживать высокую скорость произвольного доступа,
                    несмотря на то, что заполняется она последовательно.</p>
                <p>Может ли возникнуть исключение? По-видимому, да, если, например, размер возвращаемого массива
                    меньше суммы длин двух коллекций.</p>
            </aside>
        </section>
        <section style="text-align: left">
            <b>Корректное программирование (merge sort Haskell)</b>
            <pre><code class="haskell" data-trim>
merge []         ys                   = ys
merge xs         []                   = xs
merge xs@(x:xt) ys@(y:yt) | x <= y    = x : merge xt ys
                          | otherwise = y : merge xs yt
            </code></pre>
            <pre class="fragment"><code class="haskell" data-trim>
split (x:y:zs) = let (xs,ys) = split zs in (x:xs,y:ys)
split [x]      = ([x],[])
split []       = ([],[])
 
mergeSort []  = []
mergeSort [x] = [x]
mergeSort xs  = let (as,bs) = split xs
                in merge (mergeSort as) (mergeSort bs)
            </code></pre>
            <aside class="notes">
                <p>Рассмотрим теперь тот же кусочек алгоритма, использующий неизменяемые структуры данных.</p>
                <p>Во-первых, мы записываем два тривиальных случая, что если один из списков уже пустой, то
                возвращаем другой, никакого слияния не требуется.</p>
                <p>Далее, мы раскладываем поступившие данные в нашем пространстве имен с помощью сопоставления
                с образцом. При этом хотя мы и ввели сразу 6 новых имен, однако никаких особенных требований к
                коллекциям мы не предъявили - всего лишь доступ к первому элементу и представление
                    остатка коллекции.
                </p>
                <p>Выполняем промежуточное вычисление, в данном случае, x<=y и merge для остатков списков.
                </p>
                <p>После чего собираем результирующую структуру.</p>
                <p>На что здесь можно обратить внимание? Во-первых, здесь имена не меняют своих значений
                    по ходу работы. То есть мы имеем 6 констант.</p>
                <p>Во-вторых, в правильности результатов можно убедиться, посмотрев на возвращаемую структуру.
                    Первым элементом этой структуры всегда будет меньший элемент.</p>
                <p>В-третьих, так как в ходе рекурсивного вызова мы всегда передаём функции merge аргументы,
                    один из которых укорочен, то можно прийти к выводу, что вычисление гарантированно завершатся
                    при любых входных параметрах и мы получим ответы.
                </p>
            </aside>
        </section>
        <section style="text-align: left">
            <b>Корректное программирование (2)</b>
            <ul>
                <li class="fragment">
                    Все имена - константы в пределах области видимости</li>
                <li class="fragment">Нет эфемерного состояния</li>
                <li class="fragment">Нет неожиданных побочных эффектов</li>
            </ul>
            <ul>
                <li>
                 </li>
                <li class="fragment"></li>
            </ul>
            <aside class="notes">
                <p>Какие преимущества дают неизменяемые данные с точки зрения корректности программы?</p>
                <p>[NF] Программисту легче рассуждать о работе программы, если он может опереться на
                    константы. Любое имя имеет неизменный смысл после объявления и во всех случаях использования.

                </p>
                <p>[NF] Переменная же от строчки к строчке имеет разное содержимое, и даже в одной строчке
                    переменная может иметь различное содержимое в зависимости от номера итерации.
                    При анализе кода это создает дополнительную нагрузку и возможность ошибиться.</p>
                <p>[NF] Опасно передавать изменяемые структуры данных в другие методы и сторонние библиотеки.
                При некоторых условиях данные могут оказаться повреждены.</p>

            </aside>
        </section>
        <section style="text-align: left">
            <b>Производительность (память)</b>
            <ul>
                <li class="fragment">Результаты вычислений - новые структуры данных</li>
                <li class="fragment">Сборка мусора!</li>
                <li class="fragment">Алгоритмы - специальные</li>
            </ul>
            <aside class="notes">
                <p>Собственно вычисления - аналогичны по производительности, поэтому про них мы ничего особенного не
                    будем говорить.
                </p>
                <p>[NF] Однако память при таком подходе расходуется достаточно активно.</p>
                <p>Для многих вычислений необходимо сконструировать результат вычисления. Причем практически на
                    каждом уровне выполнения мы должны упаковать результаты в некоторую структуру.</p>
                <p>[NF] Алгоритмы - другие. Однако похоже, что обычно удается найти алгоритмы, обладающие аналогичной
                    ассимптотической сложностью. На практике оказывается, что при массовой обработке на первое место
                    выходят затраты на обработку отдельных элементов, а накладные расходы на коллекции окупаются.
                </p>

                <p>[NF] </p>
                <p>[NF] </p>
                <p>[NF] </p>
            </aside>
        </section>
        <!--<section style="text-align: left">-->
            <!--<b>Выделение памяти, сборка мусора</b>-->
            <!--<pre><code class="scala" data-trim>-->
            <!--</code></pre>-->
            <!--<aside class="notes">-->
                <!--<p></p>-->
                <!--<p></p>-->
                <!--<p></p>-->
                <!--<p></p>-->
                <!--<p></p>-->
            <!--</aside>-->
        <!--</section>-->

        <section style="text-align: left">
            <b>Заключение</b>
            <ul>
                <li>Неизменяемые данные - в арсенал программиста</li>
                <li>В многопоточных программах - обязательно</li>
                <li></li>
            </ul>
            <aside class="notes">
                <p>В заключение хочу призвать программистов активно использовать неизменяемые данные и
                создавать корректные программы.</p>
                <p>Если же вы пишете многопоточные программы, то вы избежите много часов отладки, если все
                    разделяемые данные будут неизменяемыми. Правда, вы потеряете увлекательную возможность
                    проявить свои детективные способности по отлавливанию редко проявляющихся багов.
                </p>
                <p></p>
            </aside>
        </section>
        <section style="text-align: left">

            <div class="fragment">
                <p></p>
                <b>Вопросы?</b>
                <p>
                    <small>Арсений Жижелев, <a href="http://primetalk.ru/">Праймтолк</a> / <a
                            href="mailto:zhizhelev@primetalk.ru">zhizhelev@primetalk.ru</a></small>
                </p>

            </div>
            <aside class="notes">
                <p>Вопросы</p>
            </aside>
        </section>
    </div>
</div>

<script src="reveal-js/lib/js/head.min.js"></script>
<script src="reveal-js/js/reveal.js"></script>

<script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'reveal-js/plugin/markdown/marked.js' },
          { src: 'reveal-js/plugin/markdown/markdown.js' },
          { src: 'reveal-js/plugin/notes/notes.js', async: true },
          { src: 'reveal-js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
